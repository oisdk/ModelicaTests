/* Main Simulation File */
/* Simulation code for PipesValveDiscrete generated by the OpenModelica Compiler OpenModelica 1.9.3. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "PipesValveDiscrete_functions.h"
#include "PipesValveDiscrete_model.h"
#include "PipesValveDiscrete_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif

#define prefixedName_performSimulation PipesValveDiscrete_performSimulation
#define prefixedName_updateContinuousSystem PipesValveDiscrete_updateContinuousSystem
#include <simulation/solver/perform_simulation.c>

#define prefixedName_performQSSSimulation PipesValveDiscrete_performQSSSimulation
#include <simulation/solver/perform_qss_simulation.c>

/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#if defined(__cplusplus)
extern "C" {
#endif
int measure_time_flag = 0;

int PipesValveDiscrete_input_function(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}

int PipesValveDiscrete_input_function_init(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}


int PipesValveDiscrete_output_function(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  TRACE_POP
  return 0;
}


/*
 equation index: 140
 type: SIMPLE_ASSIGN
 valve._open = if time >= valveOpening.startTime then not valveOpening.startValue else valveOpening.startValue
 */
void PipesValveDiscrete_eqFunction_140(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,140};
  modelica_boolean tmp497;
  RELATIONHYSTERESIS(tmp497, data->localData[0]->timeValue, $PvalveOpening$PstartTime, 2, GreaterEq);
  $Pvalve$Popen = (tmp497?(!$PvalveOpening$PstartValue):$PvalveOpening$PstartValue);
  TRACE_POP
}
/*
 equation index: 141
 type: SIMPLE_ASSIGN
 tank2._regularFlow[1] = tank2.level >= tank2.portsData[1].height
 */
void PipesValveDiscrete_eqFunction_141(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,141};
  modelica_boolean tmp498;
  RELATIONHYSTERESIS(tmp498, $Ptank2$Plevel, $Ptank2$PportsData$lB1$rB$Pheight, 1, GreaterEq);
  $Ptank2$PregularFlow$lB1$rB = tmp498;
  TRACE_POP
}
/*
 equation index: 142
 type: SIMPLE_ASSIGN
 tank2._ports_penetration[1] = Modelica.Fluid.Utilities.regStep(tank2.level + -0.1 * tank2.portsData[1].diameter - tank2.portsData[1].height, 1.0, 0.001, 0.1 * tank2.portsData[1].diameter)
 */
void PipesValveDiscrete_eqFunction_142(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,142};
  $Ptank2$Pports_penetration$lB1$rB = omc_Modelica_Fluid_Utilities_regStep(threadData, ($Ptank2$Plevel + ((-0.1 * $Ptank2$PportsData$lB1$rB$Pdiameter) - $Ptank2$PportsData$lB1$rB$Pheight)), 1.0, 0.001, (0.1 * $Ptank2$PportsData$lB1$rB$Pdiameter));
  TRACE_POP
}
/*
 equation index: 143
 type: SIMPLE_ASSIGN
 tank2._vessel_ps_static[1] = 995.586 * max(0.0, tank2.level - tank2.portsData[1].height) * system.g + tank2.p_ambient
 */
void PipesValveDiscrete_eqFunction_143(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,143};
  $Ptank2$Pvessel_ps_static$lB1$rB = ((995.586 * (fmax(0.0,($Ptank2$Plevel - $Ptank2$PportsData$lB1$rB$Pheight)) * $Psystem$Pg)) + $Ptank2$Pp_ambient);
  TRACE_POP
}
/*
 equation index: 144
 type: SIMPLE_ASSIGN
 tank2._heatTransfer._Ts[1] = Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.temperature(Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.ThermodynamicState(tank2.p_ambient, tank2.medium.T))
 */
void PipesValveDiscrete_eqFunction_144(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,144};
  $Ptank2$PheatTransfer$PTs$lB1$rB = omc_Modelica_Fluid_Vessels_OpenTank$tank2_HeatTransfer$tank2$heatTransfer_Medium_temperature(threadData, omc_Modelica_Fluid_Vessels_OpenTank$tank2_HeatTransfer$tank2$heatTransfer_Medium_ThermodynamicState(threadData, $Ptank2$Pp_ambient, $Ptank2$Pmedium$PT));
  TRACE_POP
}
/*
 equation index: 145
 type: SIMPLE_ASSIGN
 tank2._heatTransfer._surfaceAreas[1] = tank2.crossArea + 3.544907701811032 * sqrt(tank2.crossArea) * tank2.level
 */
void PipesValveDiscrete_eqFunction_145(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,145};
  modelica_real tmp499;
  tmp499 = $Ptank2$PcrossArea; 
  if(!(tmp499 >= 0.0))
  {
      {
        FILE_INFO info = {"",0,0,0,0,0};
        omc_assert_warning(info, "The following assertion has been violated at time %f", data->localData[0]->timeValue);
        throwStreamPrintWithEquationIndexes(threadData, equationIndexes, "Model error: Argument of sqrt(tank2.crossArea) was %g should be >= 0", tmp499);
      }
  }
  $Ptank2$PheatTransfer$PsurfaceAreas$lB1$rB = ($Ptank2$PcrossArea + (3.544907701811032 * (sqrt(tmp499) * $Ptank2$Plevel)));
  TRACE_POP
}
/*
 equation index: 146
 type: SIMPLE_ASSIGN
 tank2._ports[1]._h_outflow = Modelica.Fluid.Vessels.OpenTank$tank2.Medium.specificEnthalpy_pTX(tank2.p_ambient, tank2.medium.T, {1.0})
 */
void PipesValveDiscrete_eqFunction_146(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,146};
  $Ptank2$Pports$lB1$rB$Ph_outflow = omc_Modelica_Fluid_Vessels_OpenTank$tank2_Medium_specificEnthalpy__pTX(threadData, $Ptank2$Pp_ambient, $Ptank2$Pmedium$PT, _OMC_LIT30);
  TRACE_POP
}
/*
 equation index: 147
 type: SIMPLE_ASSIGN
 pipe._port_a._h_outflow = tank2.ports[1].h_outflow + system.g * pipe.height_ab
 */
void PipesValveDiscrete_eqFunction_147(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,147};
  $Ppipe$Pport_a$Ph_outflow = ($Ptank2$Pports$lB1$rB$Ph_outflow + ($Psystem$Pg * $Ppipe$Pheight_ab));
  TRACE_POP
}
/*
 equation index: 148
 type: SIMPLE_ASSIGN
 pipe._flowModel._states[2]._T = 273.15 + tank2.ports[1].h_outflow / 4184.0
 */
void PipesValveDiscrete_eqFunction_148(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,148};
  modelica_real tmp500;
  tmp500 = 4184.0;
  if (tmp500 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank2.ports[1].h_outflow / 4184.0");}
  $Ppipe$PflowModel$Pstates$lB2$rB$PT = (273.15 + ($Ptank2$Pports$lB1$rB$Ph_outflow / 4184.0));
  TRACE_POP
}
/*
 equation index: 149
 type: SIMPLE_ASSIGN
 valve._state_b._T = 273.15 + tank2.ports[1].h_outflow / 4184.0
 */
void PipesValveDiscrete_eqFunction_149(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,149};
  modelica_real tmp501;
  tmp501 = 4184.0;
  if (tmp501 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank2.ports[1].h_outflow / 4184.0");}
  $Pvalve$Pstate_b$PT = (273.15 + ($Ptank2$Pports$lB1$rB$Ph_outflow / 4184.0));
  TRACE_POP
}
/*
 equation index: 150
 type: SIMPLE_ASSIGN
 tank1._regularFlow[1] = tank1.level >= tank1.portsData[1].height
 */
void PipesValveDiscrete_eqFunction_150(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,150};
  modelica_boolean tmp502;
  RELATIONHYSTERESIS(tmp502, $Ptank1$Plevel, $Ptank1$PportsData$lB1$rB$Pheight, 0, GreaterEq);
  $Ptank1$PregularFlow$lB1$rB = tmp502;
  TRACE_POP
}
/*
 equation index: 151
 type: SIMPLE_ASSIGN
 tank1._ports_penetration[1] = Modelica.Fluid.Utilities.regStep(tank1.level + -0.1 * tank1.portsData[1].diameter - tank1.portsData[1].height, 1.0, 0.001, 0.1 * tank1.portsData[1].diameter)
 */
void PipesValveDiscrete_eqFunction_151(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,151};
  $Ptank1$Pports_penetration$lB1$rB = omc_Modelica_Fluid_Utilities_regStep(threadData, ($Ptank1$Plevel + ((-0.1 * $Ptank1$PportsData$lB1$rB$Pdiameter) - $Ptank1$PportsData$lB1$rB$Pheight)), 1.0, 0.001, (0.1 * $Ptank1$PportsData$lB1$rB$Pdiameter));
  TRACE_POP
}
/*
 equation index: 152
 type: SIMPLE_ASSIGN
 tank1._vessel_ps_static[1] = 995.586 * max(0.0, tank1.level - tank1.portsData[1].height) * system.g + tank1.p_ambient
 */
void PipesValveDiscrete_eqFunction_152(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,152};
  $Ptank1$Pvessel_ps_static$lB1$rB = ((995.586 * (fmax(0.0,($Ptank1$Plevel - $Ptank1$PportsData$lB1$rB$Pheight)) * $Psystem$Pg)) + $Ptank1$Pp_ambient);
  TRACE_POP
}
/*
 equation index: 153
 type: SIMPLE_ASSIGN
 tank1._heatTransfer._Ts[1] = Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.temperature(Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.ThermodynamicState(tank1.p_ambient, tank1.medium.T))
 */
void PipesValveDiscrete_eqFunction_153(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,153};
  $Ptank1$PheatTransfer$PTs$lB1$rB = omc_Modelica_Fluid_Vessels_OpenTank$tank1_HeatTransfer$tank1$heatTransfer_Medium_temperature(threadData, omc_Modelica_Fluid_Vessels_OpenTank$tank1_HeatTransfer$tank1$heatTransfer_Medium_ThermodynamicState(threadData, $Ptank1$Pp_ambient, $Ptank1$Pmedium$PT));
  TRACE_POP
}
/*
 equation index: 154
 type: SIMPLE_ASSIGN
 tank1._heatTransfer._surfaceAreas[1] = tank1.crossArea + 3.544907701811032 * sqrt(tank1.crossArea) * tank1.level
 */
void PipesValveDiscrete_eqFunction_154(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,154};
  modelica_real tmp503;
  tmp503 = $Ptank1$PcrossArea; 
  if(!(tmp503 >= 0.0))
  {
      {
        FILE_INFO info = {"",0,0,0,0,0};
        omc_assert_warning(info, "The following assertion has been violated at time %f", data->localData[0]->timeValue);
        throwStreamPrintWithEquationIndexes(threadData, equationIndexes, "Model error: Argument of sqrt(tank1.crossArea) was %g should be >= 0", tmp503);
      }
  }
  $Ptank1$PheatTransfer$PsurfaceAreas$lB1$rB = ($Ptank1$PcrossArea + (3.544907701811032 * (sqrt(tmp503) * $Ptank1$Plevel)));
  TRACE_POP
}
/*
 equation index: 155
 type: SIMPLE_ASSIGN
 tank1._ports[1]._h_outflow = Modelica.Fluid.Vessels.OpenTank$tank1.Medium.specificEnthalpy_pTX(tank1.p_ambient, tank1.medium.T, {1.0})
 */
void PipesValveDiscrete_eqFunction_155(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,155};
  $Ptank1$Pports$lB1$rB$Ph_outflow = omc_Modelica_Fluid_Vessels_OpenTank$tank1_Medium_specificEnthalpy__pTX(threadData, $Ptank1$Pp_ambient, $Ptank1$Pmedium$PT, _OMC_LIT30);
  TRACE_POP
}
/*
 equation index: 156
 type: SIMPLE_ASSIGN
 pipe._flowModel._states[1]._T = 273.15 + tank1.ports[1].h_outflow / 4184.0
 */
void PipesValveDiscrete_eqFunction_156(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,156};
  modelica_real tmp504;
  tmp504 = 4184.0;
  if (tmp504 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank1.ports[1].h_outflow / 4184.0");}
  $Ppipe$PflowModel$Pstates$lB1$rB$PT = (273.15 + ($Ptank1$Pports$lB1$rB$Ph_outflow / 4184.0));
  TRACE_POP
}
void PipesValveDiscrete_eqFunction_157(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_158(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_159(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_160(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_161(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_162(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_163(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_164(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_165(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_171(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_170(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_169(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_168(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_167(DATA*,threadData_t*);
void PipesValveDiscrete_eqFunction_166(DATA*,threadData_t*);
/*
 equation index: 172
 indexNonlinear: 1
 type: NONLINEAR
 
 vars: {tank1._s[1], tank2._s[1], tank2._ports[1]._p, pipe._flowModel._states[2]._p, pipe._flowModel._states[1]._p, tank1._mb_flow}
 eqns: {157, 158, 159, 160, 161, 162, 163, 164, 165, 171, 170, 169, 168, 167, 166}
 */
void PipesValveDiscrete_eqFunction_172(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,172};
  int retValue;
  if(ACTIVE_STREAM(LOG_DT))
  {
    infoStreamPrint(LOG_DT, 1, "Solving nonlinear system 172 (STRICT TEARING SET if tearing enabled) at time = %18.10e", data->localData[0]->timeValue);
    messageClose(LOG_DT);
  }
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[1].nlsx[0] = $Ptank1$Ps$lB1$rB;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[0] = _$Ptank1$Ps$lB1$rB(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[0] = extraPolate(data, _$Ptank1$Ps$lB1$rB(1) /*old1*/, _$Ptank1$Ps$lB1$rB(2) /*old2*/, $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.min, $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[1] = $Ptank2$Ps$lB1$rB;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[1] = _$Ptank2$Ps$lB1$rB(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[1] = extraPolate(data, _$Ptank2$Ps$lB1$rB(1) /*old1*/, _$Ptank2$Ps$lB1$rB(2) /*old2*/, $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.min, $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[2] = $Ptank2$Pports$lB1$rB$Pp;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[2] = _$Ptank2$Pports$lB1$rB$Pp(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[2] = extraPolate(data, _$Ptank2$Pports$lB1$rB$Pp(1) /*old1*/, _$Ptank2$Pports$lB1$rB$Pp(2) /*old2*/, $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.min, $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[3] = $Ppipe$PflowModel$Pstates$lB2$rB$Pp;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[3] = _$Ppipe$PflowModel$Pstates$lB2$rB$Pp(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[3] = extraPolate(data, _$Ppipe$PflowModel$Pstates$lB2$rB$Pp(1) /*old1*/, _$Ppipe$PflowModel$Pstates$lB2$rB$Pp(2) /*old2*/, $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.min, $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[4] = $Ppipe$PflowModel$Pstates$lB1$rB$Pp;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[4] = _$Ppipe$PflowModel$Pstates$lB1$rB$Pp(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[4] = extraPolate(data, _$Ppipe$PflowModel$Pstates$lB1$rB$Pp(1) /*old1*/, _$Ppipe$PflowModel$Pstates$lB1$rB$Pp(2) /*old2*/, $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.min, $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[5] = $Ptank1$Pmb_flow;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[5] = _$Ptank1$Pmb_flow(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[5] = extraPolate(data, _$Ptank1$Pmb_flow(1) /*old1*/, _$Ptank1$Pmb_flow(2) /*old2*/, $P$ATTRIBUTE$Ptank1$Pmb_flow.min, $P$ATTRIBUTE$Ptank1$Pmb_flow.max);
  retValue = solve_nonlinear_system(data, threadData, 1);
  /* check if solution process was successful */
  if (retValue > 0){
    const int indexes[2] = {1,172};
    throwStreamPrintWithEquationIndexes(threadData, indexes, "Solving non-linear system 172 failed at time=%.15g.\nFor more information please use -lv LOG_NLS.", data->localData[0]->timeValue);
  }
  /* write solution */
  $Ptank1$Ps$lB1$rB = data->simulationInfo.nonlinearSystemData[1].nlsx[0];
  $Ptank2$Ps$lB1$rB = data->simulationInfo.nonlinearSystemData[1].nlsx[1];
  $Ptank2$Pports$lB1$rB$Pp = data->simulationInfo.nonlinearSystemData[1].nlsx[2];
  $Ppipe$PflowModel$Pstates$lB2$rB$Pp = data->simulationInfo.nonlinearSystemData[1].nlsx[3];
  $Ppipe$PflowModel$Pstates$lB1$rB$Pp = data->simulationInfo.nonlinearSystemData[1].nlsx[4];
  $Ptank1$Pmb_flow = data->simulationInfo.nonlinearSystemData[1].nlsx[5];
  TRACE_POP
}
/*
 equation index: 173
 type: SIMPLE_ASSIGN
 der(tank2._fluidVolume) = tank1.mb_flow / -995.586
 */
void PipesValveDiscrete_eqFunction_173(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,173};
  modelica_real tmp509;
  tmp509 = -995.586;
  if (tmp509 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank1.mb_flow / -995.586");}
  $P$DER$Ptank2$PfluidVolume = ($Ptank1$Pmb_flow / -995.586);
  TRACE_POP
}
/*
 equation index: 174
 type: SIMPLE_ASSIGN
 der(tank2._level) = DIVISION($DER.tank2.fluidVolume, tank2.crossArea)
 */
void PipesValveDiscrete_eqFunction_174(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,174};
  $P$DER$Ptank2$Plevel = DIVISION_SIM($P$DER$Ptank2$PfluidVolume,$Ptank2$PcrossArea,"tank2.crossArea",equationIndexes);
  TRACE_POP
}
/*
 equation index: 175
 type: SIMPLE_ASSIGN
 pipe._flowModel._Is[1] = (-tank1.mb_flow) * pipe.length
 */
void PipesValveDiscrete_eqFunction_175(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,175};
  $Ppipe$PflowModel$PIs$lB1$rB = ((-$Ptank1$Pmb_flow) * $Ppipe$Plength);
  TRACE_POP
}
/*
 equation index: 176
 type: SIMPLE_ASSIGN
 der(tank1._fluidVolume) = (-tank1.mb_flow) / -995.586
 */
void PipesValveDiscrete_eqFunction_176(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,176};
  modelica_real tmp510;
  tmp510 = -995.586;
  if (tmp510 == 0) {throwStreamPrint(threadData, "Division by zero %s", "(-tank1.mb_flow) / -995.586");}
  $P$DER$Ptank1$PfluidVolume = ((-$Ptank1$Pmb_flow) / -995.586);
  TRACE_POP
}
/*
 equation index: 177
 type: SIMPLE_ASSIGN
 der(tank1._level) = DIVISION($DER.tank1.fluidVolume, tank1.crossArea)
 */
void PipesValveDiscrete_eqFunction_177(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,177};
  $P$DER$Ptank1$Plevel = DIVISION_SIM($P$DER$Ptank1$PfluidVolume,$Ptank1$PcrossArea,"tank1.crossArea",equationIndexes);
  TRACE_POP
}
/*
 equation index: 178
 type: SIMPLE_ASSIGN
 pipe._flowModel._rhos_act[1] = if noEvent((-tank1.mb_flow) > 0.0) then pipe.flowModel.rhos[1] else pipe.flowModel.rhos[2]
 */
void PipesValveDiscrete_eqFunction_178(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,178};
  modelica_boolean tmp511;
  tmp511 = Greater((-$Ptank1$Pmb_flow),0.0);
  $Ppipe$PflowModel$Prhos_act$lB1$rB = (tmp511?$Ppipe$PflowModel$Prhos$lB1$rB:$Ppipe$PflowModel$Prhos$lB2$rB);
  TRACE_POP
}
/*
 equation index: 179
 type: SIMPLE_ASSIGN
 pipe._flowModel._vs[2] = DIVISION(-tank1.mb_flow, pipe.crossArea * Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.density((*.Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.ThermodynamicState*)(pipe.flowModel.states[2])) * pipe.nParallel)
 */
void PipesValveDiscrete_eqFunction_179(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,179};
  $Ppipe$PflowModel$Pvs$lB2$rB = DIVISION_SIM((-$Ptank1$Pmb_flow),(($Ppipe$PcrossArea * omc_Modelica_Fluid_Pipes_StaticPipe$pipe_Medium_density(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT))) * $Ppipe$PnParallel),"pipe.crossArea * Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.ThermodynamicState*/(pipe.flowModel.states[2])) * pipe.nParallel",equationIndexes);
  TRACE_POP
}
/*
 equation index: 180
 type: SIMPLE_ASSIGN
 der(tank2._m) = -tank1.mb_flow
 */
void PipesValveDiscrete_eqFunction_180(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,180};
  $P$DER$Ptank2$Pm = (-$Ptank1$Pmb_flow);
  TRACE_POP
}
/*
 equation index: 181
 type: SIMPLE_ASSIGN
 der(tank1._m) = tank1.mb_flow
 */
void PipesValveDiscrete_eqFunction_181(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,181};
  $P$DER$Ptank1$Pm = $Ptank1$Pmb_flow;
  TRACE_POP
}
/*
 equation index: 182
 type: SIMPLE_ASSIGN
 pipe._flowModel._mus_act[1] = if noEvent((-tank1.mb_flow) > 0.0) then pipe.flowModel.mus[1] else pipe.flowModel.mus[2]
 */
void PipesValveDiscrete_eqFunction_182(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,182};
  modelica_boolean tmp512;
  tmp512 = Greater((-$Ptank1$Pmb_flow),0.0);
  $Ppipe$PflowModel$Pmus_act$lB1$rB = (tmp512?$Ppipe$PflowModel$Pmus$lB1$rB:$Ppipe$PflowModel$Pmus$lB2$rB);
  TRACE_POP
}
/*
 equation index: 183
 type: SIMPLE_ASSIGN
 pipe._flowModel._vs[1] = DIVISION(-tank1.mb_flow, pipe.crossArea * Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.density((*.Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.ThermodynamicState*)(pipe.flowModel.states[1])) * pipe.nParallel)
 */
void PipesValveDiscrete_eqFunction_183(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,183};
  $Ppipe$PflowModel$Pvs$lB1$rB = DIVISION_SIM((-$Ptank1$Pmb_flow),(($Ppipe$PcrossArea * omc_Modelica_Fluid_Pipes_StaticPipe$pipe_Medium_density(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT))) * $Ppipe$PnParallel),"pipe.crossArea * Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe.Medium.ThermodynamicState*/(pipe.flowModel.states[1])) * pipe.nParallel",equationIndexes);
  TRACE_POP
}
/*
 equation index: 184
 type: SIMPLE_ASSIGN
 valve._port_b._h_outflow = tank1.ports[1].h_outflow - system.g * pipe.height_ab
 */
void PipesValveDiscrete_eqFunction_184(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,184};
  $Pvalve$Pport_b$Ph_outflow = ($Ptank1$Pports$lB1$rB$Ph_outflow - ($Psystem$Pg * $Ppipe$Pheight_ab));
  TRACE_POP
}
/*
 equation index: 185
 type: SIMPLE_ASSIGN
 valve._state_a._T = 273.15 + valve.port_b.h_outflow / 4184.0
 */
void PipesValveDiscrete_eqFunction_185(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,185};
  modelica_real tmp513;
  tmp513 = 4184.0;
  if (tmp513 == 0) {throwStreamPrint(threadData, "Division by zero %s", "valve.port_b.h_outflow / 4184.0");}
  $Pvalve$Pstate_a$PT = (273.15 + ($Pvalve$Pport_b$Ph_outflow / 4184.0));
  TRACE_POP
}
/*
 equation index: 186
 type: SIMPLE_ASSIGN
 valve._V_flow = DIVISION(-tank1.mb_flow, Modelica.Fluid.Utilities.regStep(-tank1.mb_flow, Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.density(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.ThermodynamicState(pipe.flowModel.states[2].p, valve.state_a.T)), Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.density(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.ThermodynamicState(tank2.ports[1].p, valve.state_b.T)), valve.m_flow_small))
 */
void PipesValveDiscrete_eqFunction_186(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,186};
  $Pvalve$PV_flow = DIVISION_SIM((-$Ptank1$Pmb_flow),omc_Modelica_Fluid_Utilities_regStep(threadData, (-$Ptank1$Pmb_flow), omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_density(threadData, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Pvalve$Pstate_a$PT)), omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_density(threadData, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_ThermodynamicState(threadData, $Ptank2$Pports$lB1$rB$Pp, $Pvalve$Pstate_b$PT)), $Pvalve$Pm_flow_small),"Modelica.Fluid.Utilities.regStep(-tank1.mb_flow, Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.density(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.ThermodynamicState(pipe.flowModel.states[2].p, valve.state_a.T)), Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.density(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.ThermodynamicState(tank2.ports[1].p, valve.state_b.T)), valve.m_flow_small)",equationIndexes);
  TRACE_POP
}
/*
 equation index: 187
 type: SIMPLE_ASSIGN
 valve._port_a_T = Modelica.Fluid.Utilities.regStep(-tank1.mb_flow, Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.temperature(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.ThermodynamicState(pipe.flowModel.states[2].p, valve.state_a.T)), Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.temperature(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.setState_phX(pipe.flowModel.states[2].p, tank2.ports[1].h_outflow, {})), valve.m_flow_small)
 */
void PipesValveDiscrete_eqFunction_187(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,187};
  $Pvalve$Pport_a_T = omc_Modelica_Fluid_Utilities_regStep(threadData, (-$Ptank1$Pmb_flow), omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_temperature(threadData, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Pvalve$Pstate_a$PT)), omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_temperature(threadData, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_setState__phX(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ptank2$Pports$lB1$rB$Ph_outflow, _OMC_LIT33)), $Pvalve$Pm_flow_small);
  TRACE_POP
}
/*
 equation index: 188
 type: SIMPLE_ASSIGN
 tank2._ports_H_flow[1] = (-tank1.mb_flow) * smooth(0, if (-tank1.mb_flow) > 0.0 then valve.port_b.h_outflow else tank2.ports[1].h_outflow)
 */
void PipesValveDiscrete_eqFunction_188(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,188};
  modelica_boolean tmp514;
  tmp514 = Greater((-$Ptank1$Pmb_flow),0.0);
  $Ptank2$Pports_H_flow$lB1$rB = ((-$Ptank1$Pmb_flow) * (tmp514?$Pvalve$Pport_b$Ph_outflow:$Ptank2$Pports$lB1$rB$Ph_outflow));
  TRACE_POP
}
/*
 equation index: 189
 type: SIMPLE_ASSIGN
 tank2._portVelocities[1] = smooth(0, DIVISION(-tank1.mb_flow, Modelica.Fluid.Vessels.OpenTank$tank2.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX(tank2.vessel_ps_static[1], smooth(0, if (-tank1.mb_flow) > 0.0 then valve.port_b.h_outflow else tank2.ports[1].h_outflow), {})) * tank2.portAreas[1]))
 */
void PipesValveDiscrete_eqFunction_189(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,189};
  modelica_boolean tmp515;
  tmp515 = Greater((-$Ptank1$Pmb_flow),0.0);
  $Ptank2$PportVelocities$lB1$rB = DIVISION_SIM((-$Ptank1$Pmb_flow),(omc_Modelica_Fluid_Vessels_OpenTank$tank2_Medium_density(threadData, omc_Modelica_Fluid_Vessels_OpenTank$tank2_Medium_setState__phX(threadData, $Ptank2$Pvessel_ps_static$lB1$rB, (tmp515?$Pvalve$Pport_b$Ph_outflow:$Ptank2$Pports$lB1$rB$Ph_outflow), _OMC_LIT34)) * $Ptank2$PportAreas$lB1$rB),"Modelica.Fluid.Vessels.OpenTank$tank2.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX(tank2.vessel_ps_static[1], smooth(0, if (-tank1.mb_flow) > 0.0 then valve.port_b.h_outflow else tank2.ports[1].h_outflow), {})) * tank2.portAreas[1]",equationIndexes);
  TRACE_POP
}
/*
 equation index: 190
 type: SIMPLE_ASSIGN
 tank2._ports_E_flow[1] = (-tank1.mb_flow) * (0.5 * tank2.portVelocities[1] ^ 2.0 + system.g * tank2.portsData[1].height)
 */
void PipesValveDiscrete_eqFunction_190(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,190};
  modelica_real tmp516;
  tmp516 = $Ptank2$PportVelocities$lB1$rB;
  $Ptank2$Pports_E_flow$lB1$rB = ((-$Ptank1$Pmb_flow) * ((0.5 * (tmp516 * tmp516)) + ($Psystem$Pg * $Ptank2$PportsData$lB1$rB$Pheight)));
  TRACE_POP
}
/*
 equation index: 191
 type: SIMPLE_ASSIGN
 tank2._Hb_flow = tank2.ports_H_flow[1] + tank2.ports_E_flow[1]
 */
void PipesValveDiscrete_eqFunction_191(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,191};
  $Ptank2$PHb_flow = ($Ptank2$Pports_H_flow$lB1$rB + $Ptank2$Pports_E_flow$lB1$rB);
  TRACE_POP
}
/*
 equation index: 192
 type: SIMPLE_ASSIGN
 der(tank2._U) = tank2.Hb_flow
 */
void PipesValveDiscrete_eqFunction_192(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,192};
  $P$DER$Ptank2$PU = $Ptank2$PHb_flow;
  TRACE_POP
}
/*
 equation index: 193
 type: SIMPLE_ASSIGN
 valve._port_b_T = Modelica.Fluid.Utilities.regStep(tank1.mb_flow, Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.temperature(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.ThermodynamicState(tank2.ports[1].p, valve.state_b.T)), Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.temperature(Modelica.Fluid.Valves.ValveDiscrete$valve.Medium.setState_phX(tank2.ports[1].p, valve.port_b.h_outflow, {})), valve.m_flow_small)
 */
void PipesValveDiscrete_eqFunction_193(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,193};
  $Pvalve$Pport_b_T = omc_Modelica_Fluid_Utilities_regStep(threadData, $Ptank1$Pmb_flow, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_temperature(threadData, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_ThermodynamicState(threadData, $Ptank2$Pports$lB1$rB$Pp, $Pvalve$Pstate_b$PT)), omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_temperature(threadData, omc_Modelica_Fluid_Valves_ValveDiscrete$valve_Medium_setState__phX(threadData, $Ptank2$Pports$lB1$rB$Pp, $Pvalve$Pport_b$Ph_outflow, _OMC_LIT33)), $Pvalve$Pm_flow_small);
  TRACE_POP
}
/*
 equation index: 194
 type: SIMPLE_ASSIGN
 tank1._ports_H_flow[1] = tank1.mb_flow * smooth(0, if tank1.mb_flow > 0.0 then pipe.port_a.h_outflow else tank1.ports[1].h_outflow)
 */
void PipesValveDiscrete_eqFunction_194(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,194};
  modelica_boolean tmp517;
  tmp517 = Greater($Ptank1$Pmb_flow,0.0);
  $Ptank1$Pports_H_flow$lB1$rB = ($Ptank1$Pmb_flow * (tmp517?$Ppipe$Pport_a$Ph_outflow:$Ptank1$Pports$lB1$rB$Ph_outflow));
  TRACE_POP
}
/*
 equation index: 195
 type: SIMPLE_ASSIGN
 tank1._portVelocities[1] = smooth(0, DIVISION(tank1.mb_flow, Modelica.Fluid.Vessels.OpenTank$tank1.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX(tank1.vessel_ps_static[1], smooth(0, if tank1.mb_flow > 0.0 then pipe.port_a.h_outflow else tank1.ports[1].h_outflow), {})) * tank1.portAreas[1]))
 */
void PipesValveDiscrete_eqFunction_195(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,195};
  modelica_boolean tmp518;
  tmp518 = Greater($Ptank1$Pmb_flow,0.0);
  $Ptank1$PportVelocities$lB1$rB = DIVISION_SIM($Ptank1$Pmb_flow,(omc_Modelica_Fluid_Vessels_OpenTank$tank1_Medium_density(threadData, omc_Modelica_Fluid_Vessels_OpenTank$tank1_Medium_setState__phX(threadData, $Ptank1$Pvessel_ps_static$lB1$rB, (tmp518?$Ppipe$Pport_a$Ph_outflow:$Ptank1$Pports$lB1$rB$Ph_outflow), _OMC_LIT34)) * $Ptank1$PportAreas$lB1$rB),"Modelica.Fluid.Vessels.OpenTank$tank1.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX(tank1.vessel_ps_static[1], smooth(0, if tank1.mb_flow > 0.0 then pipe.port_a.h_outflow else tank1.ports[1].h_outflow), {})) * tank1.portAreas[1]",equationIndexes);
  TRACE_POP
}
/*
 equation index: 196
 type: SIMPLE_ASSIGN
 tank1._ports_E_flow[1] = tank1.mb_flow * (0.5 * tank1.portVelocities[1] ^ 2.0 + system.g * tank1.portsData[1].height)
 */
void PipesValveDiscrete_eqFunction_196(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,196};
  modelica_real tmp519;
  tmp519 = $Ptank1$PportVelocities$lB1$rB;
  $Ptank1$Pports_E_flow$lB1$rB = ($Ptank1$Pmb_flow * ((0.5 * (tmp519 * tmp519)) + ($Psystem$Pg * $Ptank1$PportsData$lB1$rB$Pheight)));
  TRACE_POP
}
/*
 equation index: 197
 type: SIMPLE_ASSIGN
 tank1._Hb_flow = tank1.ports_H_flow[1] + tank1.ports_E_flow[1]
 */
void PipesValveDiscrete_eqFunction_197(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,197};
  $Ptank1$PHb_flow = ($Ptank1$Pports_H_flow$lB1$rB + $Ptank1$Pports_E_flow$lB1$rB);
  TRACE_POP
}
/*
 equation index: 198
 type: SIMPLE_ASSIGN
 der(tank1._U) = tank1.Hb_flow
 */
void PipesValveDiscrete_eqFunction_198(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,198};
  $P$DER$Ptank1$PU = $Ptank1$PHb_flow;
  TRACE_POP
}
/*
 equation index: 199
 type: SIMPLE_ASSIGN
 tank1._medium._T_degC = -273.15 + tank1.medium.T
 */
void PipesValveDiscrete_eqFunction_199(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,199};
  $Ptank1$Pmedium$PT_degC = (-273.15 + $Ptank1$Pmedium$PT);
  TRACE_POP
}
/*
 equation index: 200
 type: SIMPLE_ASSIGN
 tank1._medium._u = 4184.0 * tank1.medium.T_degC
 */
void PipesValveDiscrete_eqFunction_200(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,200};
  $Ptank1$Pmedium$Pu = (4184.0 * $Ptank1$Pmedium$PT_degC);
  TRACE_POP
}
/*
 equation index: 201
 type: SIMPLE_ASSIGN
 tank2._medium._T_degC = -273.15 + tank2.medium.T
 */
void PipesValveDiscrete_eqFunction_201(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,201};
  $Ptank2$Pmedium$PT_degC = (-273.15 + $Ptank2$Pmedium$PT);
  TRACE_POP
}
/*
 equation index: 202
 type: SIMPLE_ASSIGN
 tank2._medium._u = 4184.0 * tank2.medium.T_degC
 */
void PipesValveDiscrete_eqFunction_202(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,202};
  $Ptank2$Pmedium$Pu = (4184.0 * $Ptank2$Pmedium$PT_degC);
  TRACE_POP
}
/*
 equation index: 203
 type: SIMPLE_ASSIGN
 tank1._fluidVolume = tank1.crossArea * tank1.level
 */
void PipesValveDiscrete_eqFunction_203(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,203};
  $Ptank1$PfluidVolume = ($Ptank1$PcrossArea * $Ptank1$Plevel);
  TRACE_POP
}
/*
 equation index: 204
 type: SIMPLE_ASSIGN
 tank1._m = 995.586 * tank1.fluidVolume
 */
void PipesValveDiscrete_eqFunction_204(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,204};
  $Ptank1$Pm = (995.586 * $Ptank1$PfluidVolume);
  TRACE_POP
}
/*
 equation index: 205
 type: SIMPLE_ASSIGN
 tank1._U = tank1.m * tank1.medium.u
 */
void PipesValveDiscrete_eqFunction_205(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,205};
  $Ptank1$PU = ($Ptank1$Pm * $Ptank1$Pmedium$Pu);
  TRACE_POP
}
/*
 equation index: 206
 type: SIMPLE_ASSIGN
 der(tank1._medium._u) = DIVISION(tank1.Hb_flow - tank1.mb_flow * tank1.medium.u, tank1.m)
 */
void PipesValveDiscrete_eqFunction_206(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,206};
  $P$DER$Ptank1$Pmedium$Pu = DIVISION_SIM(($Ptank1$PHb_flow - ($Ptank1$Pmb_flow * $Ptank1$Pmedium$Pu)),$Ptank1$Pm,"tank1.m",equationIndexes);
  TRACE_POP
}
/*
 equation index: 207
 type: SIMPLE_ASSIGN
 der(tank1._medium._T_degC) = (-$DER.tank1.medium.u) / -4184.0
 */
void PipesValveDiscrete_eqFunction_207(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,207};
  modelica_real tmp520;
  tmp520 = -4184.0;
  if (tmp520 == 0) {throwStreamPrint(threadData, "Division by zero %s", "(-$DER.tank1.medium.u) / -4184.0");}
  $P$DER$Ptank1$Pmedium$PT_degC = ((-$P$DER$Ptank1$Pmedium$Pu) / -4184.0);
  TRACE_POP
}
/*
 equation index: 208
 type: SIMPLE_ASSIGN
 der(tank1._medium._T) = $DER.tank1.medium.T_degC
 */
void PipesValveDiscrete_eqFunction_208(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,208};
  $P$DER$Ptank1$Pmedium$PT = $P$DER$Ptank1$Pmedium$PT_degC;
  TRACE_POP
}
/*
 equation index: 209
 type: SIMPLE_ASSIGN
 tank2._fluidVolume = tank2.crossArea * tank2.level
 */
void PipesValveDiscrete_eqFunction_209(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,209};
  $Ptank2$PfluidVolume = ($Ptank2$PcrossArea * $Ptank2$Plevel);
  TRACE_POP
}
/*
 equation index: 210
 type: SIMPLE_ASSIGN
 tank2._m = 995.586 * tank2.fluidVolume
 */
void PipesValveDiscrete_eqFunction_210(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,210};
  $Ptank2$Pm = (995.586 * $Ptank2$PfluidVolume);
  TRACE_POP
}
/*
 equation index: 211
 type: SIMPLE_ASSIGN
 tank2._U = tank2.m * tank2.medium.u
 */
void PipesValveDiscrete_eqFunction_211(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,211};
  $Ptank2$PU = ($Ptank2$Pm * $Ptank2$Pmedium$Pu);
  TRACE_POP
}
/*
 equation index: 212
 type: SIMPLE_ASSIGN
 der(tank2._medium._u) = DIVISION(tank2.Hb_flow + tank1.mb_flow * tank2.medium.u, tank2.m)
 */
void PipesValveDiscrete_eqFunction_212(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,212};
  $P$DER$Ptank2$Pmedium$Pu = DIVISION_SIM(($Ptank2$PHb_flow + ($Ptank1$Pmb_flow * $Ptank2$Pmedium$Pu)),$Ptank2$Pm,"tank2.m",equationIndexes);
  TRACE_POP
}
/*
 equation index: 213
 type: SIMPLE_ASSIGN
 der(tank2._medium._T_degC) = (-$DER.tank2.medium.u) / -4184.0
 */
void PipesValveDiscrete_eqFunction_213(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,213};
  modelica_real tmp521;
  tmp521 = -4184.0;
  if (tmp521 == 0) {throwStreamPrint(threadData, "Division by zero %s", "(-$DER.tank2.medium.u) / -4184.0");}
  $P$DER$Ptank2$Pmedium$PT_degC = ((-$P$DER$Ptank2$Pmedium$Pu) / -4184.0);
  TRACE_POP
}
/*
 equation index: 214
 type: SIMPLE_ASSIGN
 der(tank2._medium._T) = $DER.tank2.medium.T_degC
 */
void PipesValveDiscrete_eqFunction_214(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,214};
  $P$DER$Ptank2$Pmedium$PT = $P$DER$Ptank2$Pmedium$PT_degC;
  TRACE_POP
}
/*
 equation index: 223
 type: ALGORITHM
 
   assert(pipe.length >= pipe.height_ab, "Parameter length must be greater or equal height_ab.");
 */
void PipesValveDiscrete_eqFunction_223(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,223};
  modelica_boolean tmp522;
  static const MMC_DEFSTRINGLIT(tmp523,52,"Parameter length must be greater or equal height_ab.");
  static int tmp524 = 0;
  {
    tmp522 = GreaterEq($Ppipe$Plength,$Ppipe$Pheight_ab);
    if(!tmp522)
    {
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",281,7,281,90,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.length >= pipe.height_ab", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(MMC_REFSTRINGLIT(tmp523)));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 222
 type: ALGORITHM
 
   assert(tank1.medium.T >= 272.15 and tank1.medium.T <= 403.15, "
 Temperature T (= " + String(tank1.medium.T, 0, true, 6) + " K) is not
 in the allowed range (" + String(272.15, 0, true, 6) + " K <= T <= " + String(403.15, 0, true, 6) + " K)
 required from medium model \"" + "SimpleLiquidWater" + "\".
 ");
 */
void PipesValveDiscrete_eqFunction_222(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,222};
  modelica_boolean tmp525;
  modelica_boolean tmp526;
  static const MMC_DEFSTRINGLIT(tmp527,18,"\nTemperature T (= ");
  modelica_string tmp528;
  static const MMC_DEFSTRINGLIT(tmp529,33," K) is not\nin the allowed range (");
  modelica_string tmp530;
  static const MMC_DEFSTRINGLIT(tmp531,11," K <= T <= ");
  modelica_string tmp532;
  static const MMC_DEFSTRINGLIT(tmp533,32," K)\nrequired from medium model \"");
  static const MMC_DEFSTRINGLIT(tmp534,17,"SimpleLiquidWater");
  static const MMC_DEFSTRINGLIT(tmp535,3,"\".\n");
  static int tmp536 = 0;
  modelica_metatype tmpMeta[8] __attribute__((unused)) = {0};
  {
    tmp525 = GreaterEq($Ptank1$Pmedium$PT,272.15);
    tmp526 = LessEq($Ptank1$Pmedium$PT,403.15);
    if(!(tmp525 && tmp526))
    {
      tmp528 = modelica_real_to_modelica_string($Ptank1$Pmedium$PT, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp527),tmp528);
      tmpMeta[1] = stringAppend(tmpMeta[0],MMC_REFSTRINGLIT(tmp529));
      tmp530 = modelica_real_to_modelica_string(272.15, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[2] = stringAppend(tmpMeta[1],tmp530);
      tmpMeta[3] = stringAppend(tmpMeta[2],MMC_REFSTRINGLIT(tmp531));
      tmp532 = modelica_real_to_modelica_string(403.15, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[4] = stringAppend(tmpMeta[3],tmp532);
      tmpMeta[5] = stringAppend(tmpMeta[4],MMC_REFSTRINGLIT(tmp533));
      tmpMeta[6] = stringAppend(tmpMeta[5],MMC_REFSTRINGLIT(tmp534));
      tmpMeta[7] = stringAppend(tmpMeta[6],MMC_REFSTRINGLIT(tmp535));
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6384,7,6388,3,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.medium.T >= 272.15 and tank1.medium.T <= 403.15", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[7]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 221
 type: ALGORITHM
 
   assert(tank1.p_ambient >= 0.0, "Pressure (= " + String(tank1.p_ambient, 0, true, 6) + " Pa) of medium \"" + "SimpleLiquidWater" + "\" is negative
 (Temperature = " + String(tank1.medium.T, 0, true, 6) + " K)");
 */
void PipesValveDiscrete_eqFunction_221(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,221};
  modelica_boolean tmp537;
  static const MMC_DEFSTRINGLIT(tmp538,12,"Pressure (= ");
  modelica_string tmp539;
  static const MMC_DEFSTRINGLIT(tmp540,16," Pa) of medium \"");
  static const MMC_DEFSTRINGLIT(tmp541,17,"SimpleLiquidWater");
  static const MMC_DEFSTRINGLIT(tmp542,29,"\" is negative\n(Temperature = ");
  modelica_string tmp543;
  static const MMC_DEFSTRINGLIT(tmp544,3," K)");
  static int tmp545 = 0;
  modelica_metatype tmpMeta[6] __attribute__((unused)) = {0};
  {
    tmp537 = GreaterEq($Ptank1$Pp_ambient,0.0);
    if(!tmp537)
    {
      tmp539 = modelica_real_to_modelica_string($Ptank1$Pp_ambient, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp538),tmp539);
      tmpMeta[1] = stringAppend(tmpMeta[0],MMC_REFSTRINGLIT(tmp540));
      tmpMeta[2] = stringAppend(tmpMeta[1],MMC_REFSTRINGLIT(tmp541));
      tmpMeta[3] = stringAppend(tmpMeta[2],MMC_REFSTRINGLIT(tmp542));
      tmp543 = modelica_real_to_modelica_string($Ptank1$Pmedium$PT, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[4] = stringAppend(tmpMeta[3],tmp543);
      tmpMeta[5] = stringAppend(tmpMeta[4],MMC_REFSTRINGLIT(tmp544));
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",4531,7,4532,76,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.p_ambient >= 0.0", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[5]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 220
 type: ALGORITHM
 
   assert(tank1.level <= 1.1, "Vessel is overflowing (fluidLevel > fluidLevel_max = " + String(tank1.level, 0, true, 6) + ")");
 */
void PipesValveDiscrete_eqFunction_220(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,220};
  modelica_boolean tmp546;
  static const MMC_DEFSTRINGLIT(tmp547,53,"Vessel is overflowing (fluidLevel > fluidLevel_max = ");
  modelica_string tmp548;
  static int tmp549 = 0;
  modelica_metatype tmpMeta[2] __attribute__((unused)) = {0};
  {
    tmp546 = LessEq($Ptank1$Plevel,1.1);
    if(!tmp546)
    {
      tmp548 = modelica_real_to_modelica_string($Ptank1$Plevel, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp547),tmp548);
      tmpMeta[1] = stringAppend(tmpMeta[0],(modelica_string) mmc_strings_len1[41]);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",314,9,314,129,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.level <= 1.1", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[1]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 219
 type: ALGORITHM
 
   assert(tank1.level > -1.1e-06, "Fluid level (= " + String(tank1.level, 0, true, 6) + ") is below zero meaning that the solution failed.");
 */
void PipesValveDiscrete_eqFunction_219(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,219};
  modelica_boolean tmp550;
  static const MMC_DEFSTRINGLIT(tmp551,15,"Fluid level (= ");
  modelica_string tmp552;
  static const MMC_DEFSTRINGLIT(tmp553,49,") is below zero meaning that the solution failed.");
  static int tmp554 = 0;
  modelica_metatype tmpMeta[2] __attribute__((unused)) = {0};
  {
    tmp550 = Greater($Ptank1$Plevel,-1.1e-06);
    if(!tmp550)
    {
      tmp552 = modelica_real_to_modelica_string($Ptank1$Plevel, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp551),tmp552);
      tmpMeta[1] = stringAppend(tmpMeta[0],MMC_REFSTRINGLIT(tmp553));
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",315,9,315,144,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.level > -1.1e-06", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[1]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 218
 type: ALGORITHM
 
   assert(tank2.medium.T >= 272.15 and tank2.medium.T <= 403.15, "
 Temperature T (= " + String(tank2.medium.T, 0, true, 6) + " K) is not
 in the allowed range (" + String(272.15, 0, true, 6) + " K <= T <= " + String(403.15, 0, true, 6) + " K)
 required from medium model \"" + "SimpleLiquidWater" + "\".
 ");
 */
void PipesValveDiscrete_eqFunction_218(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,218};
  modelica_boolean tmp555;
  modelica_boolean tmp556;
  static const MMC_DEFSTRINGLIT(tmp557,18,"\nTemperature T (= ");
  modelica_string tmp558;
  static const MMC_DEFSTRINGLIT(tmp559,33," K) is not\nin the allowed range (");
  modelica_string tmp560;
  static const MMC_DEFSTRINGLIT(tmp561,11," K <= T <= ");
  modelica_string tmp562;
  static const MMC_DEFSTRINGLIT(tmp563,32," K)\nrequired from medium model \"");
  static const MMC_DEFSTRINGLIT(tmp564,17,"SimpleLiquidWater");
  static const MMC_DEFSTRINGLIT(tmp565,3,"\".\n");
  static int tmp566 = 0;
  modelica_metatype tmpMeta[8] __attribute__((unused)) = {0};
  {
    tmp555 = GreaterEq($Ptank2$Pmedium$PT,272.15);
    tmp556 = LessEq($Ptank2$Pmedium$PT,403.15);
    if(!(tmp555 && tmp556))
    {
      tmp558 = modelica_real_to_modelica_string($Ptank2$Pmedium$PT, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp557),tmp558);
      tmpMeta[1] = stringAppend(tmpMeta[0],MMC_REFSTRINGLIT(tmp559));
      tmp560 = modelica_real_to_modelica_string(272.15, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[2] = stringAppend(tmpMeta[1],tmp560);
      tmpMeta[3] = stringAppend(tmpMeta[2],MMC_REFSTRINGLIT(tmp561));
      tmp562 = modelica_real_to_modelica_string(403.15, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[4] = stringAppend(tmpMeta[3],tmp562);
      tmpMeta[5] = stringAppend(tmpMeta[4],MMC_REFSTRINGLIT(tmp563));
      tmpMeta[6] = stringAppend(tmpMeta[5],MMC_REFSTRINGLIT(tmp564));
      tmpMeta[7] = stringAppend(tmpMeta[6],MMC_REFSTRINGLIT(tmp565));
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6384,7,6388,3,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.medium.T >= 272.15 and tank2.medium.T <= 403.15", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[7]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 217
 type: ALGORITHM
 
   assert(tank2.p_ambient >= 0.0, "Pressure (= " + String(tank2.p_ambient, 0, true, 6) + " Pa) of medium \"" + "SimpleLiquidWater" + "\" is negative
 (Temperature = " + String(tank2.medium.T, 0, true, 6) + " K)");
 */
void PipesValveDiscrete_eqFunction_217(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,217};
  modelica_boolean tmp567;
  static const MMC_DEFSTRINGLIT(tmp568,12,"Pressure (= ");
  modelica_string tmp569;
  static const MMC_DEFSTRINGLIT(tmp570,16," Pa) of medium \"");
  static const MMC_DEFSTRINGLIT(tmp571,17,"SimpleLiquidWater");
  static const MMC_DEFSTRINGLIT(tmp572,29,"\" is negative\n(Temperature = ");
  modelica_string tmp573;
  static const MMC_DEFSTRINGLIT(tmp574,3," K)");
  static int tmp575 = 0;
  modelica_metatype tmpMeta[6] __attribute__((unused)) = {0};
  {
    tmp567 = GreaterEq($Ptank2$Pp_ambient,0.0);
    if(!tmp567)
    {
      tmp569 = modelica_real_to_modelica_string($Ptank2$Pp_ambient, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp568),tmp569);
      tmpMeta[1] = stringAppend(tmpMeta[0],MMC_REFSTRINGLIT(tmp570));
      tmpMeta[2] = stringAppend(tmpMeta[1],MMC_REFSTRINGLIT(tmp571));
      tmpMeta[3] = stringAppend(tmpMeta[2],MMC_REFSTRINGLIT(tmp572));
      tmp573 = modelica_real_to_modelica_string($Ptank2$Pmedium$PT, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[4] = stringAppend(tmpMeta[3],tmp573);
      tmpMeta[5] = stringAppend(tmpMeta[4],MMC_REFSTRINGLIT(tmp574));
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",4531,7,4532,76,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.p_ambient >= 0.0", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[5]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 216
 type: ALGORITHM
 
   assert(tank2.level <= 1.1, "Vessel is overflowing (fluidLevel > fluidLevel_max = " + String(tank2.level, 0, true, 6) + ")");
 */
void PipesValveDiscrete_eqFunction_216(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,216};
  modelica_boolean tmp576;
  static const MMC_DEFSTRINGLIT(tmp577,53,"Vessel is overflowing (fluidLevel > fluidLevel_max = ");
  modelica_string tmp578;
  static int tmp579 = 0;
  modelica_metatype tmpMeta[2] __attribute__((unused)) = {0};
  {
    tmp576 = LessEq($Ptank2$Plevel,1.1);
    if(!tmp576)
    {
      tmp578 = modelica_real_to_modelica_string($Ptank2$Plevel, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp577),tmp578);
      tmpMeta[1] = stringAppend(tmpMeta[0],(modelica_string) mmc_strings_len1[41]);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",314,9,314,129,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.level <= 1.1", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[1]));
      }
    }
  }
  TRACE_POP
}
/*
 equation index: 215
 type: ALGORITHM
 
   assert(tank2.level > -1.1e-06, "Fluid level (= " + String(tank2.level, 0, true, 6) + ") is below zero meaning that the solution failed.");
 */
void PipesValveDiscrete_eqFunction_215(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,215};
  modelica_boolean tmp580;
  static const MMC_DEFSTRINGLIT(tmp581,15,"Fluid level (= ");
  modelica_string tmp582;
  static const MMC_DEFSTRINGLIT(tmp583,49,") is below zero meaning that the solution failed.");
  static int tmp584 = 0;
  modelica_metatype tmpMeta[2] __attribute__((unused)) = {0};
  {
    tmp580 = Greater($Ptank2$Plevel,-1.1e-06);
    if(!tmp580)
    {
      tmp582 = modelica_real_to_modelica_string($Ptank2$Plevel, (modelica_integer) 0, 1, (modelica_integer) 6);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp581),tmp582);
      tmpMeta[1] = stringAppend(tmpMeta[0],MMC_REFSTRINGLIT(tmp583));
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",315,9,315,144,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.level > -1.1e-06", data->localData[0]->timeValue);
        omc_assert_withEquationIndexes(threadData, info, equationIndexes, MMC_STRINGDATA(tmpMeta[1]));
      }
    }
  }
  TRACE_POP
}


int PipesValveDiscrete_functionDAE(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  int equationIndexes[1] = {0};
  modelica_metatype tmpMeta[2] __attribute__((unused)) = {0};
  
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  PipesValveDiscrete_eqFunction_140(data, threadData);

  PipesValveDiscrete_eqFunction_141(data, threadData);

  PipesValveDiscrete_eqFunction_142(data, threadData);

  PipesValveDiscrete_eqFunction_143(data, threadData);

  PipesValveDiscrete_eqFunction_144(data, threadData);

  PipesValveDiscrete_eqFunction_145(data, threadData);

  PipesValveDiscrete_eqFunction_146(data, threadData);

  PipesValveDiscrete_eqFunction_147(data, threadData);

  PipesValveDiscrete_eqFunction_148(data, threadData);

  PipesValveDiscrete_eqFunction_149(data, threadData);

  PipesValveDiscrete_eqFunction_150(data, threadData);

  PipesValveDiscrete_eqFunction_151(data, threadData);

  PipesValveDiscrete_eqFunction_152(data, threadData);

  PipesValveDiscrete_eqFunction_153(data, threadData);

  PipesValveDiscrete_eqFunction_154(data, threadData);

  PipesValveDiscrete_eqFunction_155(data, threadData);

  PipesValveDiscrete_eqFunction_156(data, threadData);

  PipesValveDiscrete_eqFunction_172(data, threadData);

  PipesValveDiscrete_eqFunction_173(data, threadData);

  PipesValveDiscrete_eqFunction_174(data, threadData);

  PipesValveDiscrete_eqFunction_175(data, threadData);

  PipesValveDiscrete_eqFunction_176(data, threadData);

  PipesValveDiscrete_eqFunction_177(data, threadData);

  PipesValveDiscrete_eqFunction_178(data, threadData);

  PipesValveDiscrete_eqFunction_179(data, threadData);

  PipesValveDiscrete_eqFunction_180(data, threadData);

  PipesValveDiscrete_eqFunction_181(data, threadData);

  PipesValveDiscrete_eqFunction_182(data, threadData);

  PipesValveDiscrete_eqFunction_183(data, threadData);

  PipesValveDiscrete_eqFunction_184(data, threadData);

  PipesValveDiscrete_eqFunction_185(data, threadData);

  PipesValveDiscrete_eqFunction_186(data, threadData);

  PipesValveDiscrete_eqFunction_187(data, threadData);

  PipesValveDiscrete_eqFunction_188(data, threadData);

  PipesValveDiscrete_eqFunction_189(data, threadData);

  PipesValveDiscrete_eqFunction_190(data, threadData);

  PipesValveDiscrete_eqFunction_191(data, threadData);

  PipesValveDiscrete_eqFunction_192(data, threadData);

  PipesValveDiscrete_eqFunction_193(data, threadData);

  PipesValveDiscrete_eqFunction_194(data, threadData);

  PipesValveDiscrete_eqFunction_195(data, threadData);

  PipesValveDiscrete_eqFunction_196(data, threadData);

  PipesValveDiscrete_eqFunction_197(data, threadData);

  PipesValveDiscrete_eqFunction_198(data, threadData);

  PipesValveDiscrete_eqFunction_199(data, threadData);

  PipesValveDiscrete_eqFunction_200(data, threadData);

  PipesValveDiscrete_eqFunction_201(data, threadData);

  PipesValveDiscrete_eqFunction_202(data, threadData);

  PipesValveDiscrete_eqFunction_203(data, threadData);

  PipesValveDiscrete_eqFunction_204(data, threadData);

  PipesValveDiscrete_eqFunction_205(data, threadData);

  PipesValveDiscrete_eqFunction_206(data, threadData);

  PipesValveDiscrete_eqFunction_207(data, threadData);

  PipesValveDiscrete_eqFunction_208(data, threadData);

  PipesValveDiscrete_eqFunction_209(data, threadData);

  PipesValveDiscrete_eqFunction_210(data, threadData);

  PipesValveDiscrete_eqFunction_211(data, threadData);

  PipesValveDiscrete_eqFunction_212(data, threadData);

  PipesValveDiscrete_eqFunction_213(data, threadData);

  PipesValveDiscrete_eqFunction_214(data, threadData);

  PipesValveDiscrete_eqFunction_223(data, threadData);

  PipesValveDiscrete_eqFunction_222(data, threadData);

  PipesValveDiscrete_eqFunction_221(data, threadData);

  PipesValveDiscrete_eqFunction_220(data, threadData);

  PipesValveDiscrete_eqFunction_219(data, threadData);

  PipesValveDiscrete_eqFunction_218(data, threadData);

  PipesValveDiscrete_eqFunction_217(data, threadData);

  PipesValveDiscrete_eqFunction_216(data, threadData);

  PipesValveDiscrete_eqFunction_215(data, threadData);
  data->simulationInfo.discreteCall = 0;
  
  TRACE_POP
  return 0;
}

int PipesValveDiscrete_symEulerUpdate(DATA *data, modelica_real dt)
{
  TRACE_PUSH
  #ifdef $P__OMC_DT
    $P__OMC_DT = dt;
  #else
    return -1;
  #endif
  
  TRACE_POP
  return 0;
}



/* forwarded equations */
extern void PipesValveDiscrete_eqFunction_140(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_141(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_142(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_143(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_146(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_147(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_148(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_150(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_151(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_152(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_155(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_156(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_172(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_173(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_174(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_176(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_177(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_184(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_188(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_189(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_190(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_191(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_194(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_195(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_196(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_197(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_199(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_200(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_201(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_202(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_203(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_204(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_206(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_207(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_208(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_209(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_210(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_212(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_213(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_214(DATA* data, threadData_t *threadData);

static void functionODE_system0(DATA *data, threadData_t *threadData)
{
  PipesValveDiscrete_eqFunction_140(data, threadData);

  PipesValveDiscrete_eqFunction_141(data, threadData);

  PipesValveDiscrete_eqFunction_142(data, threadData);

  PipesValveDiscrete_eqFunction_143(data, threadData);

  PipesValveDiscrete_eqFunction_146(data, threadData);

  PipesValveDiscrete_eqFunction_147(data, threadData);

  PipesValveDiscrete_eqFunction_148(data, threadData);

  PipesValveDiscrete_eqFunction_150(data, threadData);

  PipesValveDiscrete_eqFunction_151(data, threadData);

  PipesValveDiscrete_eqFunction_152(data, threadData);

  PipesValveDiscrete_eqFunction_155(data, threadData);

  PipesValveDiscrete_eqFunction_156(data, threadData);

  PipesValveDiscrete_eqFunction_172(data, threadData);

  PipesValveDiscrete_eqFunction_173(data, threadData);

  PipesValveDiscrete_eqFunction_174(data, threadData);

  PipesValveDiscrete_eqFunction_176(data, threadData);

  PipesValveDiscrete_eqFunction_177(data, threadData);

  PipesValveDiscrete_eqFunction_184(data, threadData);

  PipesValveDiscrete_eqFunction_188(data, threadData);

  PipesValveDiscrete_eqFunction_189(data, threadData);

  PipesValveDiscrete_eqFunction_190(data, threadData);

  PipesValveDiscrete_eqFunction_191(data, threadData);

  PipesValveDiscrete_eqFunction_194(data, threadData);

  PipesValveDiscrete_eqFunction_195(data, threadData);

  PipesValveDiscrete_eqFunction_196(data, threadData);

  PipesValveDiscrete_eqFunction_197(data, threadData);

  PipesValveDiscrete_eqFunction_199(data, threadData);

  PipesValveDiscrete_eqFunction_200(data, threadData);

  PipesValveDiscrete_eqFunction_201(data, threadData);

  PipesValveDiscrete_eqFunction_202(data, threadData);

  PipesValveDiscrete_eqFunction_203(data, threadData);

  PipesValveDiscrete_eqFunction_204(data, threadData);

  PipesValveDiscrete_eqFunction_206(data, threadData);

  PipesValveDiscrete_eqFunction_207(data, threadData);

  PipesValveDiscrete_eqFunction_208(data, threadData);

  PipesValveDiscrete_eqFunction_209(data, threadData);

  PipesValveDiscrete_eqFunction_210(data, threadData);

  PipesValveDiscrete_eqFunction_212(data, threadData);

  PipesValveDiscrete_eqFunction_213(data, threadData);

  PipesValveDiscrete_eqFunction_214(data, threadData);
}

int PipesValveDiscrete_functionODE(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  
  data->simulationInfo.callStatistics.functionODE++;
  
  functionODE_system0(data, threadData);

  
  TRACE_POP
  return 0;
}

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data, threadData_t *threadData);

#include "PipesValveDiscrete_12jac.h"
#include "PipesValveDiscrete_13opt.h"

struct OpenModelicaGeneratedFunctionCallbacks PipesValveDiscrete_callback = {
   (int (*)(DATA *, threadData_t *, void *)) PipesValveDiscrete_performSimulation,
   (int (*)(DATA *, threadData_t *, void *)) PipesValveDiscrete_performQSSSimulation,
   PipesValveDiscrete_updateContinuousSystem,
   PipesValveDiscrete_callExternalObjectConstructors,
   PipesValveDiscrete_callExternalObjectDestructors,
   PipesValveDiscrete_initialNonLinearSystem,
   PipesValveDiscrete_initialLinearSystem,
   PipesValveDiscrete_initialMixedSystem,
   PipesValveDiscrete_initializeStateSets,
   PipesValveDiscrete_functionODE,
   PipesValveDiscrete_functionAlgebraics,
   PipesValveDiscrete_functionDAE,
   PipesValveDiscrete_input_function,
   PipesValveDiscrete_input_function_init,
   PipesValveDiscrete_output_function,
   PipesValveDiscrete_function_storeDelayed,
   PipesValveDiscrete_updateBoundVariableAttributes,
   1 /* useHomotopy */,
   PipesValveDiscrete_functionInitialEquations,
   PipesValveDiscrete_functionRemovedInitialEquations,
   PipesValveDiscrete_updateBoundParameters,
   PipesValveDiscrete_checkForAsserts,
   PipesValveDiscrete_function_ZeroCrossingsEquations,
   PipesValveDiscrete_function_ZeroCrossings,
   PipesValveDiscrete_function_updateRelations,
   PipesValveDiscrete_checkForDiscreteChanges,
   PipesValveDiscrete_zeroCrossingDescription,
   PipesValveDiscrete_relationDescription,
   PipesValveDiscrete_function_initSample,
   PipesValveDiscrete_INDEX_JAC_A,
   PipesValveDiscrete_INDEX_JAC_B,
   PipesValveDiscrete_INDEX_JAC_C,
   PipesValveDiscrete_INDEX_JAC_D,
   PipesValveDiscrete_initialAnalyticJacobianA,
   PipesValveDiscrete_initialAnalyticJacobianB,
   PipesValveDiscrete_initialAnalyticJacobianC,
   PipesValveDiscrete_initialAnalyticJacobianD,
   PipesValveDiscrete_functionJacA_column,
   PipesValveDiscrete_functionJacB_column,
   PipesValveDiscrete_functionJacC_column,
   PipesValveDiscrete_functionJacD_column,
   PipesValveDiscrete_linear_model_frame,
   PipesValveDiscrete_mayer,
   PipesValveDiscrete_lagrange,
   PipesValveDiscrete_pickUpBoundsForInputsInOptimization,
   PipesValveDiscrete_setInputData,
   PipesValveDiscrete_getTimeGrid,
   PipesValveDiscrete_symEulerUpdate,
   PipesValveDiscrete_function_initSynchronous,
   PipesValveDiscrete_function_updateSynchronous,
   PipesValveDiscrete_function_equationsSynchronous

};

void PipesValveDiscrete_setupDataStruc(DATA *data, threadData_t *threadData)
{
  assertStreamPrint(threadData,0!=data, "Error while initialize Data");
  data->callback = &PipesValveDiscrete_callback;
  data->modelData.modelName = "PipesValveDiscrete";
  data->modelData.modelFilePrefix = "PipesValveDiscrete";
  data->modelData.resultFileName = NULL;
  data->modelData.modelDir = "/Users/oisinkidney/Desktop/Code/ModelicaTests";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  #ifdef OPENMODELICA_XML_FROM_FILE_AT_RUNTIME
  data->modelData.initXMLData = NULL;
  data->modelData.modelDataXml.infoXMLData = NULL;
  #else
  data->modelData.initXMLData =
  #include "PipesValveDiscrete_init.c"
  ;
  data->modelData.modelDataXml.infoXMLData =
  #include "PipesValveDiscrete_info.c"
  ;
  #endif
  
  data->modelData.nStates = 4;
  data->modelData.nVariablesReal = 2*4+88+0+0 + 0;
  data->modelData.nDiscreteReal = 0;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 5;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 81;
  data->modelData.nParametersInteger = 20;
  data->modelData.nParametersBoolean = 39;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 0;
  
  data->modelData.nAliasReal = 67;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 1;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 5;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 5;
  data->modelData.nMathEvents = 0;
  data->modelData.nExtObjs = 0;
  setupModelInfoFunctions(1);
  data->modelData.modelDataXml.fileName = "PipesValveDiscrete_info.json";
  data->modelData.modelDataXml.modelInfoXmlLength = 0;
  data->modelData.modelDataXml.nFunctions = 49;
  data->modelData.modelDataXml.nProfileBlocks = 0;
  data->modelData.modelDataXml.nEquations = 371;
  data->modelData.nMixedSystems = 0;
  data->modelData.nLinearSystems = 0;
  data->modelData.nNonLinearSystems = 2;
  data->modelData.nStateSets = 0;
  data->modelData.nJacobians = 4;
  data->modelData.nOptimizeConstraints = 0;
  data->modelData.nOptimizeFinalConstraints = 0;
  
  data->modelData.nDelayExpressions = 0;
  
  data->modelData.nClocks = 0;
  data->modelData.nSubClocks = 0;
  
}

#ifdef __cplusplus
}
#endif

static int rml_execution_failed()
{
  fflush(NULL);
  fprintf(stderr, "Execution failed!\n");
  fflush(NULL);
  return 1;
}

#if defined(threadData)
#undef threadData
#endif
/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  int res;
  DATA simulation_data;
  MMC_INIT();omc_alloc_interface.init();
  {
    MMC_TRY_TOP()
  
    MMC_TRY_STACK()
  
    PipesValveDiscrete_setupDataStruc(&simulation_data, threadData);
    res = _main_SimulationRuntime(argc, argv, &simulation_data, threadData);
    
    MMC_ELSE()
    rml_execution_failed();
    fprintf(stderr, "Stack overflow detected and was not caught.\nSend us a bug report at https://trac.openmodelica.org/OpenModelica/newticket\n    Include the following trace:\n");
    printStacktraceMessages();
    fflush(NULL);
    return 1;
    MMC_CATCH_STACK()
    
    MMC_CATCH_TOP(return rml_execution_failed());
  }

  fflush(NULL);
  EXIT(res);
  return res;
}

