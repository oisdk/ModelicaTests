/* Non Linear Systems */
/* Simulation code for PipesValveDiscrete generated by the OpenModelica Compiler OpenModelica 1.9.3. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "PipesValveDiscrete_functions.h"
#include "PipesValveDiscrete_model.h"
#include "PipesValveDiscrete_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#include "PipesValveDiscrete_12jac.h"
#if defined(__cplusplus)
extern "C" {
#endif

/*
 equation index: 91
 type: SIMPLE_ASSIGN
 pipe._flowModel._rhos[1] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.density(pipe.flowModel.states[1])
 */
void PipesValveDiscrete_eqFunction_91(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,91};
  $Ppipe$PflowModel$Prhos$lB1$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_density(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT));
  TRACE_POP
}
/*
 equation index: 92
 type: SIMPLE_ASSIGN
 pipe._flowModel._mus[1] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.dynamicViscosity(pipe.flowModel.states[1])
 */
void PipesValveDiscrete_eqFunction_92(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,92};
  $Ppipe$PflowModel$Pmus$lB1$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_dynamicViscosity(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT));
  TRACE_POP
}
/*
 equation index: 93
 type: SIMPLE_ASSIGN
 pipe._flowModel._Fs_p[1] = pipe.crossArea * (Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.pressure(pipe.flowModel.states[2]) - Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.pressure(pipe.flowModel.states[1])) * pipe.flowModel.nParallel
 */
void PipesValveDiscrete_eqFunction_93(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,93};
  $Ppipe$PflowModel$PFs_p$lB1$rB = ($Ppipe$PcrossArea * ((omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_pressure(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT)) - omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_pressure(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT))) * $Ppipe$PflowModel$PnParallel));
  TRACE_POP
}
/*
 equation index: 94
 type: SIMPLE_ASSIGN
 pipe._flowModel._rhos[2] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.density(pipe.flowModel.states[2])
 */
void PipesValveDiscrete_eqFunction_94(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,94};
  $Ppipe$PflowModel$Prhos$lB2$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_density(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT));
  TRACE_POP
}
/*
 equation index: 95
 type: SIMPLE_ASSIGN
 pipe._flowModel._dps_fg[1] = DIVISION(-pipe.flowModel.Fs_p[1], pipe.flowModel.nParallel * pipe.crossArea)
 */
void PipesValveDiscrete_eqFunction_95(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,95};
  $Ppipe$PflowModel$Pdps_fg$lB1$rB = DIVISION_SIM((-$Ppipe$PflowModel$PFs_p$lB1$rB),($Ppipe$PflowModel$PnParallel * $Ppipe$PcrossArea),"pipe.flowModel.nParallel * pipe.crossArea",equationIndexes);
  TRACE_POP
}
/*
 equation index: 96
 type: SIMPLE_ASSIGN
 pipe._flowModel._mus[2] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.dynamicViscosity(pipe.flowModel.states[2])
 */
void PipesValveDiscrete_eqFunction_96(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,96};
  $Ppipe$PflowModel$Pmus$lB2$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_dynamicViscosity(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT));
  TRACE_POP
}
/*
 equation index: 97
 type: SIMPLE_ASSIGN
 valve._dp = pipe.flowModel.states[2].p - tank2.ports[1].p
 */
void PipesValveDiscrete_eqFunction_97(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,97};
  $Pvalve$Pdp = ($Ppipe$PflowModel$Pstates$lB2$rB$Pp - $Ptank2$Pports$lB1$rB$Pp);
  TRACE_POP
}
/*
 equation index: 98
 type: SIMPLE_ASSIGN
 tank1._inFlow[1] = not tank1.regularFlow[1] and (tank1.s[1] > 0.0 or tank1.portsData[1].height >= 1.1)
 */
void PipesValveDiscrete_eqFunction_98(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,98};
  modelica_boolean tmp1101;
  modelica_boolean tmp1102;
  RELATIONHYSTERESIS(tmp1101, $Ptank1$Ps$lB1$rB, 0.0, 3, Greater);
  tmp1102 = GreaterEq($Ptank1$PportsData$lB1$rB$Pheight,1.1);
  $Ptank1$PinFlow$lB1$rB = ((!$Ptank1$PregularFlow$lB1$rB) && (tmp1101 || tmp1102));
  TRACE_POP
}
/*
 equation index: 99
 type: SIMPLE_ASSIGN
 tank2._inFlow[1] = not tank2.regularFlow[1] and (tank2.s[1] > 0.0 or tank2.portsData[1].height >= 1.1)
 */
void PipesValveDiscrete_eqFunction_99(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,99};
  modelica_boolean tmp1103;
  modelica_boolean tmp1104;
  RELATIONHYSTERESIS(tmp1103, $Ptank2$Ps$lB1$rB, 0.0, 4, Greater);
  tmp1104 = GreaterEq($Ptank2$PportsData$lB1$rB$Pheight,1.1);
  $Ptank2$PinFlow$lB1$rB = ((!$Ptank2$PregularFlow$lB1$rB) && (tmp1103 || tmp1104));
  TRACE_POP
}
void initializeStaticNLSData106(void *inData, threadData_t *threadData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $Ptank2$Ps$lB1$rB */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.max;
  /* static nls data for $Ptank1$Ps$lB1$rB */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.max;
  /* static nls data for $Ptank2$Pports$lB1$rB$Pp */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.max;
  /* static nls data for $Ppipe$PflowModel$Pstates$lB2$rB$Pp */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.max;
  /* static nls data for $Ppipe$PflowModel$Pstates$lB1$rB$Pp */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.max;
  /* static nls data for $Ptank1$Pmb_flow */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank1$Pmb_flow.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank1$Pmb_flow.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank1$Pmb_flow.max;
}

void residualFunc106(void** dataIn, const double* xloc, double* res, const int* iflag)
{
  DATA *data = (DATA*) ((void**)dataIn[0]);
  threadData_t *threadData = (threadData_t*) ((void**)dataIn[1]);
  const int equationIndexes[2] = {1,106};
  modelica_real tmp1105;
  modelica_real tmp1106;
  modelica_real tmp1107;
  modelica_boolean tmp1108;
  modelica_real tmp1109;
  modelica_real tmp1110;
  modelica_real tmp1111;
  modelica_real tmp1112;
  modelica_boolean tmp1113;
  modelica_real tmp1114;
  $Ptank2$Ps$lB1$rB = xloc[0];
  $Ptank1$Ps$lB1$rB = xloc[1];
  $Ptank2$Pports$lB1$rB$Pp = xloc[2];
  $Ppipe$PflowModel$Pstates$lB2$rB$Pp = xloc[3];
  $Ppipe$PflowModel$Pstates$lB1$rB$Pp = xloc[4];
  $Ptank1$Pmb_flow = xloc[5];

  PipesValveDiscrete_eqFunction_91(data, threadData);

  PipesValveDiscrete_eqFunction_92(data, threadData);

  PipesValveDiscrete_eqFunction_93(data, threadData);

  PipesValveDiscrete_eqFunction_94(data, threadData);

  PipesValveDiscrete_eqFunction_95(data, threadData);

  PipesValveDiscrete_eqFunction_96(data, threadData);

  PipesValveDiscrete_eqFunction_97(data, threadData);

  PipesValveDiscrete_eqFunction_98(data, threadData);

  PipesValveDiscrete_eqFunction_99(data, threadData);

  tmp1108 = (modelica_boolean)$Ptank2$PregularFlow$lB1$rB;
  if(tmp1108)
  {
    tmp1105 = $Ptank2$PportAreas$lB1$rB;
    tmp1106 = 995.586;
    if (tmp1106 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank2.ports_penetration[1] / 995.586");}
    tmp1107 = $Ptank2$PportAreas$lB1$rB;
    tmp1109 = ($Ptank2$Pports$lB1$rB$Pp - homotopy(($Ptank2$Pvessel_ps_static$lB1$rB + (0.5 * (real_int_pow(threadData, $Ptank2$PportAreas$lB1$rB, -2) * omc_Modelica_Fluid_Utilities_regSquare2(threadData, (-$Ptank1$Pmb_flow), $Ptank2$Pm_flow_small, ((-1.0 + ($Ptank2$PportsData$lB1$rB$Pzeta_in + (tmp1105 * tmp1105))) * ($Ptank2$Pports_penetration$lB1$rB / 995.586)), DIVISION_SIM((1.0 + ($Ptank2$PportsData$lB1$rB$Pzeta_out - (tmp1107 * tmp1107))),($Ptank2$Pports_penetration$lB1$rB * 995.586),"tank2.ports_penetration[1] * 995.586",equationIndexes), 0, 1.0)))), $Ptank2$Pvessel_ps_static$lB1$rB));
  }
  else
  {
    tmp1109 = ($Ptank2$PinFlow$lB1$rB?($Ptank2$Pports$lB1$rB$Pp - $Ptank2$Pvessel_ps_static$lB1$rB):(-$Ptank1$Pmb_flow));
  }
  res[0] = tmp1109;

  res[1] = ($Ptank2$PregularFlow$lB1$rB?($Ptank2$Ps$lB1$rB - ($Ptank2$Plevel - $Ptank2$PportsData$lB1$rB$Pheight)):($Ptank2$PinFlow$lB1$rB?($Ptank2$Ps$lB1$rB + $Ptank1$Pmb_flow):($Ptank2$Ps$lB1$rB - (9.869232667160129e-06 * (($Ptank2$Pports$lB1$rB$Pp - $Ptank2$Pvessel_ps_static$lB1$rB) * ($Ptank2$PportsData$lB1$rB$Pheight - $Ptank2$Plevel))))));

  tmp1113 = (modelica_boolean)$Ptank1$PregularFlow$lB1$rB;
  if(tmp1113)
  {
    tmp1110 = $Ptank1$PportAreas$lB1$rB;
    tmp1111 = 995.586;
    if (tmp1111 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank1.ports_penetration[1] / 995.586");}
    tmp1112 = $Ptank1$PportAreas$lB1$rB;
    tmp1114 = ($Ppipe$PflowModel$Pstates$lB1$rB$Pp - homotopy(($Ptank1$Pvessel_ps_static$lB1$rB + (0.5 * (real_int_pow(threadData, $Ptank1$PportAreas$lB1$rB, -2) * omc_Modelica_Fluid_Utilities_regSquare2(threadData, $Ptank1$Pmb_flow, $Ptank1$Pm_flow_small, ((-1.0 + ($Ptank1$PportsData$lB1$rB$Pzeta_in + (tmp1110 * tmp1110))) * ($Ptank1$Pports_penetration$lB1$rB / 995.586)), DIVISION_SIM((1.0 + ($Ptank1$PportsData$lB1$rB$Pzeta_out - (tmp1112 * tmp1112))),($Ptank1$Pports_penetration$lB1$rB * 995.586),"tank1.ports_penetration[1] * 995.586",equationIndexes), 0, 1.0)))), $Ptank1$Pvessel_ps_static$lB1$rB));
  }
  else
  {
    tmp1114 = ($Ptank1$PinFlow$lB1$rB?($Ppipe$PflowModel$Pstates$lB1$rB$Pp - $Ptank1$Pvessel_ps_static$lB1$rB):$Ptank1$Pmb_flow);
  }
  res[2] = tmp1114;

  res[3] = ($Ptank1$PregularFlow$lB1$rB?($Ptank1$Ps$lB1$rB - ($Ptank1$Plevel - $Ptank1$PportsData$lB1$rB$Pheight)):($Ptank1$PinFlow$lB1$rB?($Ptank1$Ps$lB1$rB - $Ptank1$Pmb_flow):($Ptank1$Ps$lB1$rB - (9.869232667160129e-06 * (($Ppipe$PflowModel$Pstates$lB1$rB$Pp - $Ptank1$Pvessel_ps_static$lB1$rB) * ($Ptank1$PportsData$lB1$rB$Pheight - $Ptank1$Plevel))))));

  res[4] = (($Pvalve$Popen?($Pvalve$Pk * $Pvalve$Pdp):($Pvalve$Popening_min * ($Pvalve$Pk * $Pvalve$Pdp))) + $Ptank1$Pmb_flow);

  res[5] = (homotopy((omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_WallFriction_massFlowRate__dp__staticHead(threadData, $Ppipe$PflowModel$Pdps_fg$lB1$rB, $Ppipe$PflowModel$Prhos$lB1$rB, $Ppipe$PflowModel$Prhos$lB2$rB, $Ppipe$PflowModel$Pmus$lB1$rB, $Ppipe$PflowModel$Pmus$lB2$rB, $Ppipe$Plength, $Ppipe$PflowModel$Pdiameters$lB1$rB, ($Ppipe$Pheight_ab * $Ppipe$PflowModel$Pg), $Ppipe$PcrossArea, $Ppipe$Proughness, $Ppipe$PflowModel$Pdp_small, $Ppipe$PflowModel$PRe_turbulent) * $Ppipe$PflowModel$PnParallel), (($Ppipe$PflowModel$Pdps_fg$lB1$rB - (($Ppipe$Pheight_ab * $Ppipe$PflowModel$Pg) * 995.586)) * DIVISION_SIM($Ppipe$PflowModel$Pm_flow_nominal,$Ppipe$PflowModel$Pdp_nominal,"pipe.flowModel.dp_nominal",equationIndexes))) + $Ptank1$Pmb_flow);
}

/*
 equation index: 157
 type: SIMPLE_ASSIGN
 pipe._flowModel._mus[1] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.dynamicViscosity(pipe.flowModel.states[1])
 */
void PipesValveDiscrete_eqFunction_157(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,157};
  $Ppipe$PflowModel$Pmus$lB1$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_dynamicViscosity(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT));
  TRACE_POP
}
/*
 equation index: 158
 type: SIMPLE_ASSIGN
 pipe._flowModel._rhos[1] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.density(pipe.flowModel.states[1])
 */
void PipesValveDiscrete_eqFunction_158(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,158};
  $Ppipe$PflowModel$Prhos$lB1$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_density(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT));
  TRACE_POP
}
/*
 equation index: 159
 type: SIMPLE_ASSIGN
 pipe._flowModel._mus[2] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.dynamicViscosity(pipe.flowModel.states[2])
 */
void PipesValveDiscrete_eqFunction_159(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,159};
  $Ppipe$PflowModel$Pmus$lB2$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_dynamicViscosity(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT));
  TRACE_POP
}
/*
 equation index: 160
 type: SIMPLE_ASSIGN
 pipe._flowModel._rhos[2] = Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.density(pipe.flowModel.states[2])
 */
void PipesValveDiscrete_eqFunction_160(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,160};
  $Ppipe$PflowModel$Prhos$lB2$rB = omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_density(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT));
  TRACE_POP
}
/*
 equation index: 161
 type: SIMPLE_ASSIGN
 pipe._flowModel._Fs_p[1] = pipe.crossArea * (Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.pressure(pipe.flowModel.states[2]) - Modelica.Fluid.Pipes.StaticPipe$pipe.FlowModel$pipe$flowModel.Medium.pressure(pipe.flowModel.states[1])) * pipe.flowModel.nParallel
 */
void PipesValveDiscrete_eqFunction_161(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,161};
  $Ppipe$PflowModel$PFs_p$lB1$rB = ($Ppipe$PcrossArea * ((omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_pressure(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB2$rB$Pp, $Ppipe$PflowModel$Pstates$lB2$rB$PT)) - omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_pressure(threadData, omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_Medium_ThermodynamicState(threadData, $Ppipe$PflowModel$Pstates$lB1$rB$Pp, $Ppipe$PflowModel$Pstates$lB1$rB$PT))) * $Ppipe$PflowModel$PnParallel));
  TRACE_POP
}
/*
 equation index: 162
 type: SIMPLE_ASSIGN
 pipe._flowModel._dps_fg[1] = DIVISION(-pipe.flowModel.Fs_p[1], pipe.flowModel.nParallel * pipe.crossArea)
 */
void PipesValveDiscrete_eqFunction_162(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,162};
  $Ppipe$PflowModel$Pdps_fg$lB1$rB = DIVISION_SIM((-$Ppipe$PflowModel$PFs_p$lB1$rB),($Ppipe$PflowModel$PnParallel * $Ppipe$PcrossArea),"pipe.flowModel.nParallel * pipe.crossArea",equationIndexes);
  TRACE_POP
}
/*
 equation index: 163
 type: SIMPLE_ASSIGN
 valve._dp = pipe.flowModel.states[2].p - tank2.ports[1].p
 */
void PipesValveDiscrete_eqFunction_163(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,163};
  $Pvalve$Pdp = ($Ppipe$PflowModel$Pstates$lB2$rB$Pp - $Ptank2$Pports$lB1$rB$Pp);
  TRACE_POP
}
/*
 equation index: 164
 type: SIMPLE_ASSIGN
 tank2._inFlow[1] = not tank2.regularFlow[1] and (tank2.s[1] > 0.0 or tank2.portsData[1].height >= 1.1)
 */
void PipesValveDiscrete_eqFunction_164(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,164};
  modelica_boolean tmp1115;
  modelica_boolean tmp1116;
  RELATIONHYSTERESIS(tmp1115, $Ptank2$Ps$lB1$rB, 0.0, 4, Greater);
  tmp1116 = GreaterEq($Ptank2$PportsData$lB1$rB$Pheight,1.1);
  $Ptank2$PinFlow$lB1$rB = ((!$Ptank2$PregularFlow$lB1$rB) && (tmp1115 || tmp1116));
  TRACE_POP
}
/*
 equation index: 165
 type: SIMPLE_ASSIGN
 tank1._inFlow[1] = not tank1.regularFlow[1] and (tank1.s[1] > 0.0 or tank1.portsData[1].height >= 1.1)
 */
void PipesValveDiscrete_eqFunction_165(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,165};
  modelica_boolean tmp1117;
  modelica_boolean tmp1118;
  RELATIONHYSTERESIS(tmp1117, $Ptank1$Ps$lB1$rB, 0.0, 3, Greater);
  tmp1118 = GreaterEq($Ptank1$PportsData$lB1$rB$Pheight,1.1);
  $Ptank1$PinFlow$lB1$rB = ((!$Ptank1$PregularFlow$lB1$rB) && (tmp1117 || tmp1118));
  TRACE_POP
}
void initializeStaticNLSData172(void *inData, threadData_t *threadData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $Ptank1$Ps$lB1$rB */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank1$Ps$lB1$rB.max;
  /* static nls data for $Ptank2$Ps$lB1$rB */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank2$Ps$lB1$rB.max;
  /* static nls data for $Ptank2$Pports$lB1$rB$Pp */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Pp.max;
  /* static nls data for $Ppipe$PflowModel$Pstates$lB2$rB$Pp */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB2$rB$Pp.max;
  /* static nls data for $Ppipe$PflowModel$Pstates$lB1$rB$Pp */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ppipe$PflowModel$Pstates$lB1$rB$Pp.max;
  /* static nls data for $Ptank1$Pmb_flow */
  nlsData->nominal[i] = $P$ATTRIBUTE$Ptank1$Pmb_flow.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$Ptank1$Pmb_flow.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$Ptank1$Pmb_flow.max;
}

void residualFunc172(void** dataIn, const double* xloc, double* res, const int* iflag)
{
  DATA *data = (DATA*) ((void**)dataIn[0]);
  threadData_t *threadData = (threadData_t*) ((void**)dataIn[1]);
  const int equationIndexes[2] = {1,172};
  modelica_real tmp1119;
  modelica_real tmp1120;
  modelica_real tmp1121;
  modelica_boolean tmp1122;
  modelica_real tmp1123;
  modelica_real tmp1124;
  modelica_real tmp1125;
  modelica_real tmp1126;
  modelica_boolean tmp1127;
  modelica_real tmp1128;
  $Ptank1$Ps$lB1$rB = xloc[0];
  $Ptank2$Ps$lB1$rB = xloc[1];
  $Ptank2$Pports$lB1$rB$Pp = xloc[2];
  $Ppipe$PflowModel$Pstates$lB2$rB$Pp = xloc[3];
  $Ppipe$PflowModel$Pstates$lB1$rB$Pp = xloc[4];
  $Ptank1$Pmb_flow = xloc[5];

  PipesValveDiscrete_eqFunction_157(data, threadData);

  PipesValveDiscrete_eqFunction_158(data, threadData);

  PipesValveDiscrete_eqFunction_159(data, threadData);

  PipesValveDiscrete_eqFunction_160(data, threadData);

  PipesValveDiscrete_eqFunction_161(data, threadData);

  PipesValveDiscrete_eqFunction_162(data, threadData);

  PipesValveDiscrete_eqFunction_163(data, threadData);

  PipesValveDiscrete_eqFunction_164(data, threadData);

  PipesValveDiscrete_eqFunction_165(data, threadData);

  res[0] = (($Pvalve$Popen?($Pvalve$Pk * $Pvalve$Pdp):($Pvalve$Popening_min * ($Pvalve$Pk * $Pvalve$Pdp))) + $Ptank1$Pmb_flow);

  res[1] = ($Ptank1$PregularFlow$lB1$rB?($Ptank1$Ps$lB1$rB - ($Ptank1$Plevel - $Ptank1$PportsData$lB1$rB$Pheight)):($Ptank1$PinFlow$lB1$rB?($Ptank1$Ps$lB1$rB - $Ptank1$Pmb_flow):($Ptank1$Ps$lB1$rB - (9.869232667160129e-06 * (($Ppipe$PflowModel$Pstates$lB1$rB$Pp - $Ptank1$Pvessel_ps_static$lB1$rB) * ($Ptank1$PportsData$lB1$rB$Pheight - $Ptank1$Plevel))))));

  tmp1122 = (modelica_boolean)$Ptank1$PregularFlow$lB1$rB;
  if(tmp1122)
  {
    tmp1119 = $Ptank1$PportAreas$lB1$rB;
    tmp1120 = 995.586;
    if (tmp1120 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank1.ports_penetration[1] / 995.586");}
    tmp1121 = $Ptank1$PportAreas$lB1$rB;
    tmp1123 = ($Ppipe$PflowModel$Pstates$lB1$rB$Pp - homotopy(($Ptank1$Pvessel_ps_static$lB1$rB + (0.5 * (real_int_pow(threadData, $Ptank1$PportAreas$lB1$rB, -2) * omc_Modelica_Fluid_Utilities_regSquare2(threadData, $Ptank1$Pmb_flow, $Ptank1$Pm_flow_small, ((-1.0 + ($Ptank1$PportsData$lB1$rB$Pzeta_in + (tmp1119 * tmp1119))) * ($Ptank1$Pports_penetration$lB1$rB / 995.586)), DIVISION_SIM((1.0 + ($Ptank1$PportsData$lB1$rB$Pzeta_out - (tmp1121 * tmp1121))),($Ptank1$Pports_penetration$lB1$rB * 995.586),"tank1.ports_penetration[1] * 995.586",equationIndexes), 0, 1.0)))), $Ptank1$Pvessel_ps_static$lB1$rB));
  }
  else
  {
    tmp1123 = ($Ptank1$PinFlow$lB1$rB?($Ppipe$PflowModel$Pstates$lB1$rB$Pp - $Ptank1$Pvessel_ps_static$lB1$rB):$Ptank1$Pmb_flow);
  }
  res[2] = tmp1123;

  res[3] = ($Ptank2$PregularFlow$lB1$rB?($Ptank2$Ps$lB1$rB - ($Ptank2$Plevel - $Ptank2$PportsData$lB1$rB$Pheight)):($Ptank2$PinFlow$lB1$rB?($Ptank2$Ps$lB1$rB + $Ptank1$Pmb_flow):($Ptank2$Ps$lB1$rB - (9.869232667160129e-06 * (($Ptank2$Pports$lB1$rB$Pp - $Ptank2$Pvessel_ps_static$lB1$rB) * ($Ptank2$PportsData$lB1$rB$Pheight - $Ptank2$Plevel))))));

  tmp1127 = (modelica_boolean)$Ptank2$PregularFlow$lB1$rB;
  if(tmp1127)
  {
    tmp1124 = $Ptank2$PportAreas$lB1$rB;
    tmp1125 = 995.586;
    if (tmp1125 == 0) {throwStreamPrint(threadData, "Division by zero %s", "tank2.ports_penetration[1] / 995.586");}
    tmp1126 = $Ptank2$PportAreas$lB1$rB;
    tmp1128 = ($Ptank2$Pports$lB1$rB$Pp - homotopy(($Ptank2$Pvessel_ps_static$lB1$rB + (0.5 * (real_int_pow(threadData, $Ptank2$PportAreas$lB1$rB, -2) * omc_Modelica_Fluid_Utilities_regSquare2(threadData, (-$Ptank1$Pmb_flow), $Ptank2$Pm_flow_small, ((-1.0 + ($Ptank2$PportsData$lB1$rB$Pzeta_in + (tmp1124 * tmp1124))) * ($Ptank2$Pports_penetration$lB1$rB / 995.586)), DIVISION_SIM((1.0 + ($Ptank2$PportsData$lB1$rB$Pzeta_out - (tmp1126 * tmp1126))),($Ptank2$Pports_penetration$lB1$rB * 995.586),"tank2.ports_penetration[1] * 995.586",equationIndexes), 0, 1.0)))), $Ptank2$Pvessel_ps_static$lB1$rB));
  }
  else
  {
    tmp1128 = ($Ptank2$PinFlow$lB1$rB?($Ptank2$Pports$lB1$rB$Pp - $Ptank2$Pvessel_ps_static$lB1$rB):(-$Ptank1$Pmb_flow));
  }
  res[4] = tmp1128;

  res[5] = (homotopy((omc_Modelica_Fluid_Pipes_StaticPipe$pipe_FlowModel$pipe$flowModel_WallFriction_massFlowRate__dp__staticHead(threadData, $Ppipe$PflowModel$Pdps_fg$lB1$rB, $Ppipe$PflowModel$Prhos$lB1$rB, $Ppipe$PflowModel$Prhos$lB2$rB, $Ppipe$PflowModel$Pmus$lB1$rB, $Ppipe$PflowModel$Pmus$lB2$rB, $Ppipe$Plength, $Ppipe$PflowModel$Pdiameters$lB1$rB, ($Ppipe$Pheight_ab * $Ppipe$PflowModel$Pg), $Ppipe$PcrossArea, $Ppipe$Proughness, $Ppipe$PflowModel$Pdp_small, $Ppipe$PflowModel$PRe_turbulent) * $Ppipe$PflowModel$PnParallel), (($Ppipe$PflowModel$Pdps_fg$lB1$rB - (($Ppipe$Pheight_ab * $Ppipe$PflowModel$Pg) * 995.586)) * DIVISION_SIM($Ppipe$PflowModel$Pm_flow_nominal,$Ppipe$PflowModel$Pdp_nominal,"pipe.flowModel.dp_nominal",equationIndexes))) + $Ptank1$Pmb_flow);
}

/* function initialize non-linear systems */

void PipesValveDiscrete_initialNonLinearSystem(int nNonLinearSystems, NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
  assertStreamPrint(NULL, nNonLinearSystems > 0, "Internal Error: nNonLinearSystems mismatch!");
  nonLinearSystemData[0].equationIndex = 106;
  nonLinearSystemData[0].size = 6;
  nonLinearSystemData[0].method = 0;
  nonLinearSystemData[0].homotopySupport = 1;
  nonLinearSystemData[0].mixedSystem = 1;
  nonLinearSystemData[0].residualFunc = residualFunc106;
  nonLinearSystemData[0].strictTearingFunctionCall = NULL;
  nonLinearSystemData[0].analyticalJacobianColumn = NULL;
  nonLinearSystemData[0].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[0].jacobianIndex = -1;
  nonLinearSystemData[0].initializeStaticNLSData = initializeStaticNLSData106;
  assertStreamPrint(NULL, nNonLinearSystems > 1, "Internal Error: nNonLinearSystems mismatch!");
  nonLinearSystemData[1].equationIndex = 172;
  nonLinearSystemData[1].size = 6;
  nonLinearSystemData[1].method = 0;
  nonLinearSystemData[1].homotopySupport = 1;
  nonLinearSystemData[1].mixedSystem = 1;
  nonLinearSystemData[1].residualFunc = residualFunc172;
  nonLinearSystemData[1].strictTearingFunctionCall = NULL;
  nonLinearSystemData[1].analyticalJacobianColumn = NULL;
  nonLinearSystemData[1].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[1].jacobianIndex = -1;
  nonLinearSystemData[1].initializeStaticNLSData = initializeStaticNLSData172;
}

#if defined(__cplusplus)
}
#endif

