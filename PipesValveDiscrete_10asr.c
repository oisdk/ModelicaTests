/* Asserts */
/* Simulation code for PipesValveDiscrete generated by the OpenModelica Compiler OpenModelica 1.9.3. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "PipesValveDiscrete_functions.h"
#include "PipesValveDiscrete_model.h"
#include "PipesValveDiscrete_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 337
 type: ALGORITHM
 
   assert(tank1.m >= 0.0, "Variable tank1.m out of [min, max] interval: tank1.m >= 0.0 has value: " + String(tank1.m, "g"));
 */
void PipesValveDiscrete_eqFunction_337(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,337};
  modelica_boolean tmp329;
  static const MMC_DEFSTRINGLIT(tmp330,71,"Variable tank1.m out of [min, max] interval: tank1.m >= 0.0 has value: ");
  modelica_string tmp331;
  static int tmp332 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp332)
  {
    tmp329 = GreaterEq($Ptank1$Pm,0.0);
    if(!tmp329)
    {
      tmp331 = modelica_real_to_modelica_string_format($Ptank1$Pm, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp330),tmp331);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",586,7,586,32,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.m >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp332 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 338
 type: ALGORITHM
 
   assert(tank1.mb_flow >= -100000.0 and tank1.mb_flow <= 100000.0, "Variable tank1.mb_flow out of [min, max] interval: tank1.mb_flow >= -100000.0 and tank1.mb_flow <= 100000.0 has value: " + String(tank1.mb_flow, "g"));
 */
void PipesValveDiscrete_eqFunction_338(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,338};
  modelica_boolean tmp333;
  modelica_boolean tmp334;
  static const MMC_DEFSTRINGLIT(tmp335,119,"Variable tank1.mb_flow out of [min, max] interval: tank1.mb_flow >= -100000.0 and tank1.mb_flow <= 100000.0 has value: ");
  modelica_string tmp336;
  static int tmp337 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp337)
  {
    tmp333 = GreaterEq($Ptank1$Pmb_flow,-100000.0);
    tmp334 = LessEq($Ptank1$Pmb_flow,100000.0);
    if(!(tmp333 && tmp334))
    {
      tmp336 = modelica_real_to_modelica_string_format($Ptank1$Pmb_flow, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp335),tmp336);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",594,7,594,61,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.mb_flow >= -100000.0 and tank1.mb_flow <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp337 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 339
 type: ALGORITHM
 
   assert(tank1.ports[1].h_outflow >= -10000000000.0 and tank1.ports[1].h_outflow <= 10000000000.0, "Variable tank1.ports[1].h_outflow out of [min, max] interval: tank1.ports[1].h_outflow >= -10000000000.0 and tank1.ports[1].h_outflow <= 10000000000.0 has value: " + String(tank1.ports[1].h_outflow, "g"));
 */
void PipesValveDiscrete_eqFunction_339(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,339};
  modelica_boolean tmp338;
  modelica_boolean tmp339;
  static const MMC_DEFSTRINGLIT(tmp340,162,"Variable tank1.ports[1].h_outflow out of [min, max] interval: tank1.ports[1].h_outflow >= -10000000000.0 and tank1.ports[1].h_outflow <= 10000000000.0 has value: ");
  modelica_string tmp341;
  static int tmp342 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp342)
  {
    tmp338 = GreaterEq($Ptank1$Pports$lB1$rB$Ph_outflow,-10000000000.0);
    tmp339 = LessEq($Ptank1$Pports$lB1$rB$Ph_outflow,10000000000.0);
    if(!(tmp338 && tmp339))
    {
      tmp341 = modelica_real_to_modelica_string_format($Ptank1$Pports$lB1$rB$Ph_outflow, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp340),tmp341);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",16,5,17,84,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.ports[1].h_outflow >= -10000000000.0 and tank1.ports[1].h_outflow <= 10000000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp342 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 340
 type: ALGORITHM
 
   assert(tank1.ports_H_flow[1] >= -100000000.0 and tank1.ports_H_flow[1] <= 100000000.0, "Variable tank1.ports_H_flow[1] out of [min, max] interval: tank1.ports_H_flow[1] >= -100000000.0 and tank1.ports_H_flow[1] <= 100000000.0 has value: " + String(tank1.ports_H_flow[1], "g"));
 */
void PipesValveDiscrete_eqFunction_340(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,340};
  modelica_boolean tmp343;
  modelica_boolean tmp344;
  static const MMC_DEFSTRINGLIT(tmp345,149,"Variable tank1.ports_H_flow[1] out of [min, max] interval: tank1.ports_H_flow[1] >= -100000000.0 and tank1.ports_H_flow[1] <= 100000000.0 has value: ");
  modelica_string tmp346;
  static int tmp347 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp347)
  {
    tmp343 = GreaterEq($Ptank1$Pports_H_flow$lB1$rB,-100000000.0);
    tmp344 = LessEq($Ptank1$Pports_H_flow$lB1$rB,100000000.0);
    if(!(tmp343 && tmp344))
    {
      tmp346 = modelica_real_to_modelica_string_format($Ptank1$Pports_H_flow$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp345),tmp346);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",220,9,220,53,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.ports_H_flow[1] >= -100000000.0 and tank1.ports_H_flow[1] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp347 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 341
 type: ALGORITHM
 
   assert(tank1.vessel_ps_static[1] >= 0.0 and tank1.vessel_ps_static[1] <= 100000000.0, "Variable tank1.vessel_ps_static[1] out of [min, max] interval: tank1.vessel_ps_static[1] >= 0.0 and tank1.vessel_ps_static[1] <= 100000000.0 has value: " + String(tank1.vessel_ps_static[1], "g"));
 */
void PipesValveDiscrete_eqFunction_341(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,341};
  modelica_boolean tmp348;
  modelica_boolean tmp349;
  static const MMC_DEFSTRINGLIT(tmp350,152,"Variable tank1.vessel_ps_static[1] out of [min, max] interval: tank1.vessel_ps_static[1] >= 0.0 and tank1.vessel_ps_static[1] <= 100000000.0 has value: ");
  modelica_string tmp351;
  static int tmp352 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp352)
  {
    tmp348 = GreaterEq($Ptank1$Pvessel_ps_static$lB1$rB,0.0);
    tmp349 = LessEq($Ptank1$Pvessel_ps_static$lB1$rB,100000000.0);
    if(!(tmp348 && tmp349))
    {
      tmp351 = modelica_real_to_modelica_string_format($Ptank1$Pvessel_ps_static$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp350),tmp351);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",266,9,267,106,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.vessel_ps_static[1] >= 0.0 and tank1.vessel_ps_static[1] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp352 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 342
 type: ALGORITHM
 
   assert(tank1.medium.u >= -100000000.0 and tank1.medium.u <= 100000000.0, "Variable tank1.medium.u out of [min, max] interval: tank1.medium.u >= -100000000.0 and tank1.medium.u <= 100000000.0 has value: " + String(tank1.medium.u, "g"));
 */
void PipesValveDiscrete_eqFunction_342(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,342};
  modelica_boolean tmp353;
  modelica_boolean tmp354;
  static const MMC_DEFSTRINGLIT(tmp355,128,"Variable tank1.medium.u out of [min, max] interval: tank1.medium.u >= -100000000.0 and tank1.medium.u <= 100000000.0 has value: ");
  modelica_string tmp356;
  static int tmp357 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp357)
  {
    tmp353 = GreaterEq($Ptank1$Pmedium$Pu,-100000000.0);
    tmp354 = LessEq($Ptank1$Pmedium$Pu,100000000.0);
    if(!(tmp353 && tmp354))
    {
      tmp356 = modelica_real_to_modelica_string_format($Ptank1$Pmedium$Pu, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp355),tmp356);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",4487,7,4487,68,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.medium.u >= -100000000.0 and tank1.medium.u <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp357 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 343
 type: ALGORITHM
 
   assert(tank1.medium.T >= 1.0 and tank1.medium.T <= 10000.0, "Variable tank1.medium.T out of [min, max] interval: tank1.medium.T >= 1.0 and tank1.medium.T <= 10000.0 has value: " + String(tank1.medium.T, "g"));
 */
void PipesValveDiscrete_eqFunction_343(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,343};
  modelica_boolean tmp358;
  modelica_boolean tmp359;
  static const MMC_DEFSTRINGLIT(tmp360,115,"Variable tank1.medium.T out of [min, max] interval: tank1.medium.T >= 1.0 and tank1.medium.T <= 10000.0 has value: ");
  modelica_string tmp361;
  static int tmp362 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp362)
  {
    tmp358 = GreaterEq($Ptank1$Pmedium$PT,1.0);
    tmp359 = LessEq($Ptank1$Pmedium$PT,10000.0);
    if(!(tmp358 && tmp359))
    {
      tmp361 = modelica_real_to_modelica_string_format($Ptank1$Pmedium$PT, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp360),tmp361);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",4484,7,4484,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.medium.T >= 1.0 and tank1.medium.T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp362 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 344
 type: ALGORITHM
 
   assert(tank1.level >= 0.0, "Variable tank1.level out of [min, max] interval: tank1.level >= 0.0 has value: " + String(tank1.level, "g"));
 */
void PipesValveDiscrete_eqFunction_344(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,344};
  modelica_boolean tmp363;
  static const MMC_DEFSTRINGLIT(tmp364,79,"Variable tank1.level out of [min, max] interval: tank1.level >= 0.0 has value: ");
  modelica_string tmp365;
  static int tmp366 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp366)
  {
    tmp363 = GreaterEq($Ptank1$Plevel,0.0);
    if(!tmp363)
    {
      tmp365 = modelica_real_to_modelica_string_format($Ptank1$Plevel, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp364),tmp365);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",53,3,54,29,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.level >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp366 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 345
 type: ALGORITHM
 
   assert(tank1.heatTransfer.Ts[1] >= 0.0, "Variable tank1.heatTransfer.Ts[1] out of [min, max] interval: tank1.heatTransfer.Ts[1] >= 0.0 has value: " + String(tank1.heatTransfer.Ts[1], "g"));
 */
void PipesValveDiscrete_eqFunction_345(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,345};
  modelica_boolean tmp367;
  static const MMC_DEFSTRINGLIT(tmp368,105,"Variable tank1.heatTransfer.Ts[1] out of [min, max] interval: tank1.heatTransfer.Ts[1] >= 0.0 has value: ");
  modelica_string tmp369;
  static int tmp370 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp370)
  {
    tmp367 = GreaterEq($Ptank1$PheatTransfer$PTs$lB1$rB,0.0);
    if(!tmp367)
    {
      tmp369 = modelica_real_to_modelica_string_format($Ptank1$PheatTransfer$PTs$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp368),tmp369);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",503,5,504,45,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.heatTransfer.Ts[1] >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp370 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 346
 type: ALGORITHM
 
   assert(pipe.port_a.h_outflow >= -10000000000.0 and pipe.port_a.h_outflow <= 10000000000.0, "Variable pipe.port_a.h_outflow out of [min, max] interval: pipe.port_a.h_outflow >= -10000000000.0 and pipe.port_a.h_outflow <= 10000000000.0 has value: " + String(pipe.port_a.h_outflow, "g"));
 */
void PipesValveDiscrete_eqFunction_346(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,346};
  modelica_boolean tmp371;
  modelica_boolean tmp372;
  static const MMC_DEFSTRINGLIT(tmp373,153,"Variable pipe.port_a.h_outflow out of [min, max] interval: pipe.port_a.h_outflow >= -10000000000.0 and pipe.port_a.h_outflow <= 10000000000.0 has value: ");
  modelica_string tmp374;
  static int tmp375 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp375)
  {
    tmp371 = GreaterEq($Ppipe$Pport_a$Ph_outflow,-10000000000.0);
    tmp372 = LessEq($Ppipe$Pport_a$Ph_outflow,10000000000.0);
    if(!(tmp371 && tmp372))
    {
      tmp374 = modelica_real_to_modelica_string_format($Ppipe$Pport_a$Ph_outflow, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp373),tmp374);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",16,5,17,84,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.port_a.h_outflow >= -10000000000.0 and pipe.port_a.h_outflow <= 10000000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp375 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 347
 type: ALGORITHM
 
   assert(pipe.flowModel.states[1].p >= 0.0 and pipe.flowModel.states[1].p <= 100000000.0, "Variable pipe.flowModel.states[1].p out of [min, max] interval: pipe.flowModel.states[1].p >= 0.0 and pipe.flowModel.states[1].p <= 100000000.0 has value: " + String(pipe.flowModel.states[1].p, "g"));
 */
void PipesValveDiscrete_eqFunction_347(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,347};
  modelica_boolean tmp376;
  modelica_boolean tmp377;
  static const MMC_DEFSTRINGLIT(tmp378,155,"Variable pipe.flowModel.states[1].p out of [min, max] interval: pipe.flowModel.states[1].p >= 0.0 and pipe.flowModel.states[1].p <= 100000000.0 has value: ");
  modelica_string tmp379;
  static int tmp380 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp380)
  {
    tmp376 = GreaterEq($Ppipe$PflowModel$Pstates$lB1$rB$Pp,0.0);
    tmp377 = LessEq($Ppipe$PflowModel$Pstates$lB1$rB$Pp,100000000.0);
    if(!(tmp376 && tmp377))
    {
      tmp379 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pstates$lB1$rB$Pp, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp378),tmp379);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6375,7,6375,55,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.states[1].p >= 0.0 and pipe.flowModel.states[1].p <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp380 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 348
 type: ALGORITHM
 
   assert(pipe.flowModel.states[1].T >= 1.0 and pipe.flowModel.states[1].T <= 10000.0, "Variable pipe.flowModel.states[1].T out of [min, max] interval: pipe.flowModel.states[1].T >= 1.0 and pipe.flowModel.states[1].T <= 10000.0 has value: " + String(pipe.flowModel.states[1].T, "g"));
 */
void PipesValveDiscrete_eqFunction_348(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,348};
  modelica_boolean tmp381;
  modelica_boolean tmp382;
  static const MMC_DEFSTRINGLIT(tmp383,151,"Variable pipe.flowModel.states[1].T out of [min, max] interval: pipe.flowModel.states[1].T >= 1.0 and pipe.flowModel.states[1].T <= 10000.0 has value: ");
  modelica_string tmp384;
  static int tmp385 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp385)
  {
    tmp381 = GreaterEq($Ppipe$PflowModel$Pstates$lB1$rB$PT,1.0);
    tmp382 = LessEq($Ppipe$PflowModel$Pstates$lB1$rB$PT,10000.0);
    if(!(tmp381 && tmp382))
    {
      tmp384 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pstates$lB1$rB$PT, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp383),tmp384);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6376,7,6376,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.states[1].T >= 1.0 and pipe.flowModel.states[1].T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp385 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 349
 type: ALGORITHM
 
   assert(pipe.flowModel.states[2].p >= 0.0 and pipe.flowModel.states[2].p <= 100000000.0, "Variable pipe.flowModel.states[2].p out of [min, max] interval: pipe.flowModel.states[2].p >= 0.0 and pipe.flowModel.states[2].p <= 100000000.0 has value: " + String(pipe.flowModel.states[2].p, "g"));
 */
void PipesValveDiscrete_eqFunction_349(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,349};
  modelica_boolean tmp386;
  modelica_boolean tmp387;
  static const MMC_DEFSTRINGLIT(tmp388,155,"Variable pipe.flowModel.states[2].p out of [min, max] interval: pipe.flowModel.states[2].p >= 0.0 and pipe.flowModel.states[2].p <= 100000000.0 has value: ");
  modelica_string tmp389;
  static int tmp390 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp390)
  {
    tmp386 = GreaterEq($Ppipe$PflowModel$Pstates$lB2$rB$Pp,0.0);
    tmp387 = LessEq($Ppipe$PflowModel$Pstates$lB2$rB$Pp,100000000.0);
    if(!(tmp386 && tmp387))
    {
      tmp389 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pstates$lB2$rB$Pp, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp388),tmp389);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6375,7,6375,55,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.states[2].p >= 0.0 and pipe.flowModel.states[2].p <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp390 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 350
 type: ALGORITHM
 
   assert(pipe.flowModel.states[2].T >= 1.0 and pipe.flowModel.states[2].T <= 10000.0, "Variable pipe.flowModel.states[2].T out of [min, max] interval: pipe.flowModel.states[2].T >= 1.0 and pipe.flowModel.states[2].T <= 10000.0 has value: " + String(pipe.flowModel.states[2].T, "g"));
 */
void PipesValveDiscrete_eqFunction_350(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,350};
  modelica_boolean tmp391;
  modelica_boolean tmp392;
  static const MMC_DEFSTRINGLIT(tmp393,151,"Variable pipe.flowModel.states[2].T out of [min, max] interval: pipe.flowModel.states[2].T >= 1.0 and pipe.flowModel.states[2].T <= 10000.0 has value: ");
  modelica_string tmp394;
  static int tmp395 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp395)
  {
    tmp391 = GreaterEq($Ppipe$PflowModel$Pstates$lB2$rB$PT,1.0);
    tmp392 = LessEq($Ppipe$PflowModel$Pstates$lB2$rB$PT,10000.0);
    if(!(tmp391 && tmp392))
    {
      tmp394 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pstates$lB2$rB$PT, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp393),tmp394);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6376,7,6376,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.states[2].T >= 1.0 and pipe.flowModel.states[2].T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp395 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 351
 type: ALGORITHM
 
   assert(pipe.flowModel.rhos_act[1] >= 0.0 and pipe.flowModel.rhos_act[1] <= 100000.0, "Variable pipe.flowModel.rhos_act[1] out of [min, max] interval: pipe.flowModel.rhos_act[1] >= 0.0 and pipe.flowModel.rhos_act[1] <= 100000.0 has value: " + String(pipe.flowModel.rhos_act[1], "g"));
 */
void PipesValveDiscrete_eqFunction_351(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,351};
  modelica_boolean tmp396;
  modelica_boolean tmp397;
  static const MMC_DEFSTRINGLIT(tmp398,152,"Variable pipe.flowModel.rhos_act[1] out of [min, max] interval: pipe.flowModel.rhos_act[1] >= 0.0 and pipe.flowModel.rhos_act[1] <= 100000.0 has value: ");
  modelica_string tmp399;
  static int tmp400 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp400)
  {
    tmp396 = GreaterEq($Ppipe$PflowModel$Prhos_act$lB1$rB,0.0);
    tmp397 = LessEq($Ppipe$PflowModel$Prhos_act$lB1$rB,100000.0);
    if(!(tmp396 && tmp397))
    {
      tmp399 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Prhos_act$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp398),tmp399);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1053,13,1053,70,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.rhos_act[1] >= 0.0 and pipe.flowModel.rhos_act[1] <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp400 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 352
 type: ALGORITHM
 
   assert(pipe.flowModel.mus_act[1] >= 0.0 and pipe.flowModel.mus_act[1] <= 100000000.0, "Variable pipe.flowModel.mus_act[1] out of [min, max] interval: pipe.flowModel.mus_act[1] >= 0.0 and pipe.flowModel.mus_act[1] <= 100000000.0 has value: " + String(pipe.flowModel.mus_act[1], "g"));
 */
void PipesValveDiscrete_eqFunction_352(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,352};
  modelica_boolean tmp401;
  modelica_boolean tmp402;
  static const MMC_DEFSTRINGLIT(tmp403,152,"Variable pipe.flowModel.mus_act[1] out of [min, max] interval: pipe.flowModel.mus_act[1] >= 0.0 and pipe.flowModel.mus_act[1] <= 100000000.0 has value: ");
  modelica_string tmp404;
  static int tmp405 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp405)
  {
    tmp401 = GreaterEq($Ppipe$PflowModel$Pmus_act$lB1$rB,0.0);
    tmp402 = LessEq($Ppipe$PflowModel$Pmus_act$lB1$rB,100000000.0);
    if(!(tmp401 && tmp402))
    {
      tmp404 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pmus_act$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp403),tmp404);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1056,13,1056,80,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.mus_act[1] >= 0.0 and pipe.flowModel.mus_act[1] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp405 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 353
 type: ALGORITHM
 
   assert(pipe.flowModel.rhos[1] >= 0.0 and pipe.flowModel.rhos[1] <= 100000.0, "Variable pipe.flowModel.rhos[1] out of [min, max] interval: pipe.flowModel.rhos[1] >= 0.0 and pipe.flowModel.rhos[1] <= 100000.0 has value: " + String(pipe.flowModel.rhos[1], "g"));
 */
void PipesValveDiscrete_eqFunction_353(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,353};
  modelica_boolean tmp406;
  modelica_boolean tmp407;
  static const MMC_DEFSTRINGLIT(tmp408,140,"Variable pipe.flowModel.rhos[1] out of [min, max] interval: pipe.flowModel.rhos[1] >= 0.0 and pipe.flowModel.rhos[1] <= 100000.0 has value: ");
  modelica_string tmp409;
  static int tmp410 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp410)
  {
    tmp406 = GreaterEq($Ppipe$PflowModel$Prhos$lB1$rB,0.0);
    tmp407 = LessEq($Ppipe$PflowModel$Prhos$lB1$rB,100000.0);
    if(!(tmp406 && tmp407))
    {
      tmp409 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Prhos$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp408),tmp409);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1052,13,1052,110,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.rhos[1] >= 0.0 and pipe.flowModel.rhos[1] <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp410 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 354
 type: ALGORITHM
 
   assert(pipe.flowModel.rhos[2] >= 0.0 and pipe.flowModel.rhos[2] <= 100000.0, "Variable pipe.flowModel.rhos[2] out of [min, max] interval: pipe.flowModel.rhos[2] >= 0.0 and pipe.flowModel.rhos[2] <= 100000.0 has value: " + String(pipe.flowModel.rhos[2], "g"));
 */
void PipesValveDiscrete_eqFunction_354(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,354};
  modelica_boolean tmp411;
  modelica_boolean tmp412;
  static const MMC_DEFSTRINGLIT(tmp413,140,"Variable pipe.flowModel.rhos[2] out of [min, max] interval: pipe.flowModel.rhos[2] >= 0.0 and pipe.flowModel.rhos[2] <= 100000.0 has value: ");
  modelica_string tmp414;
  static int tmp415 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp415)
  {
    tmp411 = GreaterEq($Ppipe$PflowModel$Prhos$lB2$rB,0.0);
    tmp412 = LessEq($Ppipe$PflowModel$Prhos$lB2$rB,100000.0);
    if(!(tmp411 && tmp412))
    {
      tmp414 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Prhos$lB2$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp413),tmp414);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1052,13,1052,110,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.rhos[2] >= 0.0 and pipe.flowModel.rhos[2] <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp415 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 355
 type: ALGORITHM
 
   assert(pipe.flowModel.mus[1] >= 0.0 and pipe.flowModel.mus[1] <= 100000000.0, "Variable pipe.flowModel.mus[1] out of [min, max] interval: pipe.flowModel.mus[1] >= 0.0 and pipe.flowModel.mus[1] <= 100000000.0 has value: " + String(pipe.flowModel.mus[1], "g"));
 */
void PipesValveDiscrete_eqFunction_355(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,355};
  modelica_boolean tmp416;
  modelica_boolean tmp417;
  static const MMC_DEFSTRINGLIT(tmp418,140,"Variable pipe.flowModel.mus[1] out of [min, max] interval: pipe.flowModel.mus[1] >= 0.0 and pipe.flowModel.mus[1] <= 100000000.0 has value: ");
  modelica_string tmp419;
  static int tmp420 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp420)
  {
    tmp416 = GreaterEq($Ppipe$PflowModel$Pmus$lB1$rB,0.0);
    tmp417 = LessEq($Ppipe$PflowModel$Pmus$lB1$rB,100000000.0);
    if(!(tmp416 && tmp417))
    {
      tmp419 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pmus$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp418),tmp419);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1055,13,1055,125,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.mus[1] >= 0.0 and pipe.flowModel.mus[1] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp420 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 356
 type: ALGORITHM
 
   assert(pipe.flowModel.mus[2] >= 0.0 and pipe.flowModel.mus[2] <= 100000000.0, "Variable pipe.flowModel.mus[2] out of [min, max] interval: pipe.flowModel.mus[2] >= 0.0 and pipe.flowModel.mus[2] <= 100000000.0 has value: " + String(pipe.flowModel.mus[2], "g"));
 */
void PipesValveDiscrete_eqFunction_356(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,356};
  modelica_boolean tmp421;
  modelica_boolean tmp422;
  static const MMC_DEFSTRINGLIT(tmp423,140,"Variable pipe.flowModel.mus[2] out of [min, max] interval: pipe.flowModel.mus[2] >= 0.0 and pipe.flowModel.mus[2] <= 100000000.0 has value: ");
  modelica_string tmp424;
  static int tmp425 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp425)
  {
    tmp421 = GreaterEq($Ppipe$PflowModel$Pmus$lB2$rB,0.0);
    tmp422 = LessEq($Ppipe$PflowModel$Pmus$lB2$rB,100000000.0);
    if(!(tmp421 && tmp422))
    {
      tmp424 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pmus$lB2$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp423),tmp424);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1055,13,1055,125,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.mus[2] >= 0.0 and pipe.flowModel.mus[2] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp425 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 357
 type: ALGORITHM
 
   assert(tank2.m >= 0.0, "Variable tank2.m out of [min, max] interval: tank2.m >= 0.0 has value: " + String(tank2.m, "g"));
 */
void PipesValveDiscrete_eqFunction_357(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,357};
  modelica_boolean tmp426;
  static const MMC_DEFSTRINGLIT(tmp427,71,"Variable tank2.m out of [min, max] interval: tank2.m >= 0.0 has value: ");
  modelica_string tmp428;
  static int tmp429 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp429)
  {
    tmp426 = GreaterEq($Ptank2$Pm,0.0);
    if(!tmp426)
    {
      tmp428 = modelica_real_to_modelica_string_format($Ptank2$Pm, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp427),tmp428);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",586,7,586,32,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.m >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp429 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 358
 type: ALGORITHM
 
   assert(tank2.ports[1].p >= 0.0 and tank2.ports[1].p <= 100000000.0, "Variable tank2.ports[1].p out of [min, max] interval: tank2.ports[1].p >= 0.0 and tank2.ports[1].p <= 100000000.0 has value: " + String(tank2.ports[1].p, "g"));
 */
void PipesValveDiscrete_eqFunction_358(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,358};
  modelica_boolean tmp430;
  modelica_boolean tmp431;
  static const MMC_DEFSTRINGLIT(tmp432,125,"Variable tank2.ports[1].p out of [min, max] interval: tank2.ports[1].p >= 0.0 and tank2.ports[1].p <= 100000000.0 has value: ");
  modelica_string tmp433;
  static int tmp434 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp434)
  {
    tmp430 = GreaterEq($Ptank2$Pports$lB1$rB$Pp,0.0);
    tmp431 = LessEq($Ptank2$Pports$lB1$rB$Pp,100000000.0);
    if(!(tmp430 && tmp431))
    {
      tmp433 = modelica_real_to_modelica_string_format($Ptank2$Pports$lB1$rB$Pp, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp432),tmp433);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",15,5,15,79,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.ports[1].p >= 0.0 and tank2.ports[1].p <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp434 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 359
 type: ALGORITHM
 
   assert(tank2.ports[1].h_outflow >= -10000000000.0 and tank2.ports[1].h_outflow <= 10000000000.0, "Variable tank2.ports[1].h_outflow out of [min, max] interval: tank2.ports[1].h_outflow >= -10000000000.0 and tank2.ports[1].h_outflow <= 10000000000.0 has value: " + String(tank2.ports[1].h_outflow, "g"));
 */
void PipesValveDiscrete_eqFunction_359(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,359};
  modelica_boolean tmp435;
  modelica_boolean tmp436;
  static const MMC_DEFSTRINGLIT(tmp437,162,"Variable tank2.ports[1].h_outflow out of [min, max] interval: tank2.ports[1].h_outflow >= -10000000000.0 and tank2.ports[1].h_outflow <= 10000000000.0 has value: ");
  modelica_string tmp438;
  static int tmp439 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp439)
  {
    tmp435 = GreaterEq($Ptank2$Pports$lB1$rB$Ph_outflow,-10000000000.0);
    tmp436 = LessEq($Ptank2$Pports$lB1$rB$Ph_outflow,10000000000.0);
    if(!(tmp435 && tmp436))
    {
      tmp438 = modelica_real_to_modelica_string_format($Ptank2$Pports$lB1$rB$Ph_outflow, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp437),tmp438);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",16,5,17,84,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.ports[1].h_outflow >= -10000000000.0 and tank2.ports[1].h_outflow <= 10000000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp439 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 360
 type: ALGORITHM
 
   assert(tank2.ports_H_flow[1] >= -100000000.0 and tank2.ports_H_flow[1] <= 100000000.0, "Variable tank2.ports_H_flow[1] out of [min, max] interval: tank2.ports_H_flow[1] >= -100000000.0 and tank2.ports_H_flow[1] <= 100000000.0 has value: " + String(tank2.ports_H_flow[1], "g"));
 */
void PipesValveDiscrete_eqFunction_360(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,360};
  modelica_boolean tmp440;
  modelica_boolean tmp441;
  static const MMC_DEFSTRINGLIT(tmp442,149,"Variable tank2.ports_H_flow[1] out of [min, max] interval: tank2.ports_H_flow[1] >= -100000000.0 and tank2.ports_H_flow[1] <= 100000000.0 has value: ");
  modelica_string tmp443;
  static int tmp444 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp444)
  {
    tmp440 = GreaterEq($Ptank2$Pports_H_flow$lB1$rB,-100000000.0);
    tmp441 = LessEq($Ptank2$Pports_H_flow$lB1$rB,100000000.0);
    if(!(tmp440 && tmp441))
    {
      tmp443 = modelica_real_to_modelica_string_format($Ptank2$Pports_H_flow$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp442),tmp443);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",220,9,220,53,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.ports_H_flow[1] >= -100000000.0 and tank2.ports_H_flow[1] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp444 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 361
 type: ALGORITHM
 
   assert(tank2.vessel_ps_static[1] >= 0.0 and tank2.vessel_ps_static[1] <= 100000000.0, "Variable tank2.vessel_ps_static[1] out of [min, max] interval: tank2.vessel_ps_static[1] >= 0.0 and tank2.vessel_ps_static[1] <= 100000000.0 has value: " + String(tank2.vessel_ps_static[1], "g"));
 */
void PipesValveDiscrete_eqFunction_361(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,361};
  modelica_boolean tmp445;
  modelica_boolean tmp446;
  static const MMC_DEFSTRINGLIT(tmp447,152,"Variable tank2.vessel_ps_static[1] out of [min, max] interval: tank2.vessel_ps_static[1] >= 0.0 and tank2.vessel_ps_static[1] <= 100000000.0 has value: ");
  modelica_string tmp448;
  static int tmp449 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp449)
  {
    tmp445 = GreaterEq($Ptank2$Pvessel_ps_static$lB1$rB,0.0);
    tmp446 = LessEq($Ptank2$Pvessel_ps_static$lB1$rB,100000000.0);
    if(!(tmp445 && tmp446))
    {
      tmp448 = modelica_real_to_modelica_string_format($Ptank2$Pvessel_ps_static$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp447),tmp448);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",266,9,267,106,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.vessel_ps_static[1] >= 0.0 and tank2.vessel_ps_static[1] <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp449 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 362
 type: ALGORITHM
 
   assert(tank2.medium.u >= -100000000.0 and tank2.medium.u <= 100000000.0, "Variable tank2.medium.u out of [min, max] interval: tank2.medium.u >= -100000000.0 and tank2.medium.u <= 100000000.0 has value: " + String(tank2.medium.u, "g"));
 */
void PipesValveDiscrete_eqFunction_362(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,362};
  modelica_boolean tmp450;
  modelica_boolean tmp451;
  static const MMC_DEFSTRINGLIT(tmp452,128,"Variable tank2.medium.u out of [min, max] interval: tank2.medium.u >= -100000000.0 and tank2.medium.u <= 100000000.0 has value: ");
  modelica_string tmp453;
  static int tmp454 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp454)
  {
    tmp450 = GreaterEq($Ptank2$Pmedium$Pu,-100000000.0);
    tmp451 = LessEq($Ptank2$Pmedium$Pu,100000000.0);
    if(!(tmp450 && tmp451))
    {
      tmp453 = modelica_real_to_modelica_string_format($Ptank2$Pmedium$Pu, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp452),tmp453);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",4487,7,4487,68,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.medium.u >= -100000000.0 and tank2.medium.u <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp454 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 363
 type: ALGORITHM
 
   assert(tank2.medium.T >= 1.0 and tank2.medium.T <= 10000.0, "Variable tank2.medium.T out of [min, max] interval: tank2.medium.T >= 1.0 and tank2.medium.T <= 10000.0 has value: " + String(tank2.medium.T, "g"));
 */
void PipesValveDiscrete_eqFunction_363(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,363};
  modelica_boolean tmp455;
  modelica_boolean tmp456;
  static const MMC_DEFSTRINGLIT(tmp457,115,"Variable tank2.medium.T out of [min, max] interval: tank2.medium.T >= 1.0 and tank2.medium.T <= 10000.0 has value: ");
  modelica_string tmp458;
  static int tmp459 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp459)
  {
    tmp455 = GreaterEq($Ptank2$Pmedium$PT,1.0);
    tmp456 = LessEq($Ptank2$Pmedium$PT,10000.0);
    if(!(tmp455 && tmp456))
    {
      tmp458 = modelica_real_to_modelica_string_format($Ptank2$Pmedium$PT, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp457),tmp458);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",4484,7,4484,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.medium.T >= 1.0 and tank2.medium.T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp459 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 364
 type: ALGORITHM
 
   assert(tank2.level >= 0.0, "Variable tank2.level out of [min, max] interval: tank2.level >= 0.0 has value: " + String(tank2.level, "g"));
 */
void PipesValveDiscrete_eqFunction_364(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,364};
  modelica_boolean tmp460;
  static const MMC_DEFSTRINGLIT(tmp461,79,"Variable tank2.level out of [min, max] interval: tank2.level >= 0.0 has value: ");
  modelica_string tmp462;
  static int tmp463 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp463)
  {
    tmp460 = GreaterEq($Ptank2$Plevel,0.0);
    if(!tmp460)
    {
      tmp462 = modelica_real_to_modelica_string_format($Ptank2$Plevel, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp461),tmp462);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",53,3,54,29,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.level >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp463 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 365
 type: ALGORITHM
 
   assert(tank2.heatTransfer.Ts[1] >= 0.0, "Variable tank2.heatTransfer.Ts[1] out of [min, max] interval: tank2.heatTransfer.Ts[1] >= 0.0 has value: " + String(tank2.heatTransfer.Ts[1], "g"));
 */
void PipesValveDiscrete_eqFunction_365(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,365};
  modelica_boolean tmp464;
  static const MMC_DEFSTRINGLIT(tmp465,105,"Variable tank2.heatTransfer.Ts[1] out of [min, max] interval: tank2.heatTransfer.Ts[1] >= 0.0 has value: ");
  modelica_string tmp466;
  static int tmp467 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp467)
  {
    tmp464 = GreaterEq($Ptank2$PheatTransfer$PTs$lB1$rB,0.0);
    if(!tmp464)
    {
      tmp466 = modelica_real_to_modelica_string_format($Ptank2$PheatTransfer$PTs$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp465),tmp466);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",503,5,504,45,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.heatTransfer.Ts[1] >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp467 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 366
 type: ALGORITHM
 
   assert(valve.state_a.T >= 1.0 and valve.state_a.T <= 10000.0, "Variable valve.state_a.T out of [min, max] interval: valve.state_a.T >= 1.0 and valve.state_a.T <= 10000.0 has value: " + String(valve.state_a.T, "g"));
 */
void PipesValveDiscrete_eqFunction_366(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,366};
  modelica_boolean tmp468;
  modelica_boolean tmp469;
  static const MMC_DEFSTRINGLIT(tmp470,118,"Variable valve.state_a.T out of [min, max] interval: valve.state_a.T >= 1.0 and valve.state_a.T <= 10000.0 has value: ");
  modelica_string tmp471;
  static int tmp472 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp472)
  {
    tmp468 = GreaterEq($Pvalve$Pstate_a$PT,1.0);
    tmp469 = LessEq($Pvalve$Pstate_a$PT,10000.0);
    if(!(tmp468 && tmp469))
    {
      tmp471 = modelica_real_to_modelica_string_format($Pvalve$Pstate_a$PT, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp470),tmp471);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6376,7,6376,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.state_a.T >= 1.0 and valve.state_a.T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp472 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 367
 type: ALGORITHM
 
   assert(valve.state_b.T >= 1.0 and valve.state_b.T <= 10000.0, "Variable valve.state_b.T out of [min, max] interval: valve.state_b.T >= 1.0 and valve.state_b.T <= 10000.0 has value: " + String(valve.state_b.T, "g"));
 */
void PipesValveDiscrete_eqFunction_367(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,367};
  modelica_boolean tmp473;
  modelica_boolean tmp474;
  static const MMC_DEFSTRINGLIT(tmp475,118,"Variable valve.state_b.T out of [min, max] interval: valve.state_b.T >= 1.0 and valve.state_b.T <= 10000.0 has value: ");
  modelica_string tmp476;
  static int tmp477 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp477)
  {
    tmp473 = GreaterEq($Pvalve$Pstate_b$PT,1.0);
    tmp474 = LessEq($Pvalve$Pstate_b$PT,10000.0);
    if(!(tmp473 && tmp474))
    {
      tmp476 = modelica_real_to_modelica_string_format($Pvalve$Pstate_b$PT, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp475),tmp476);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Media/package.mo",6376,7,6376,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.state_b.T >= 1.0 and valve.state_b.T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp477 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 368
 type: ALGORITHM
 
   assert(valve.port_b.h_outflow >= -10000000000.0 and valve.port_b.h_outflow <= 10000000000.0, "Variable valve.port_b.h_outflow out of [min, max] interval: valve.port_b.h_outflow >= -10000000000.0 and valve.port_b.h_outflow <= 10000000000.0 has value: " + String(valve.port_b.h_outflow, "g"));
 */
void PipesValveDiscrete_eqFunction_368(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,368};
  modelica_boolean tmp478;
  modelica_boolean tmp479;
  static const MMC_DEFSTRINGLIT(tmp480,156,"Variable valve.port_b.h_outflow out of [min, max] interval: valve.port_b.h_outflow >= -10000000000.0 and valve.port_b.h_outflow <= 10000000000.0 has value: ");
  modelica_string tmp481;
  static int tmp482 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp482)
  {
    tmp478 = GreaterEq($Pvalve$Pport_b$Ph_outflow,-10000000000.0);
    tmp479 = LessEq($Pvalve$Pport_b$Ph_outflow,10000000000.0);
    if(!(tmp478 && tmp479))
    {
      tmp481 = modelica_real_to_modelica_string_format($Pvalve$Pport_b$Ph_outflow, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp480),tmp481);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",16,5,17,84,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.port_b.h_outflow >= -10000000000.0 and valve.port_b.h_outflow <= 10000000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp482 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 369
 type: ALGORITHM
 
   assert(valve.port_a_T >= 1.0 and valve.port_a_T <= 10000.0, "Variable valve.port_a_T out of [min, max] interval: valve.port_a_T >= 1.0 and valve.port_a_T <= 10000.0 has value: " + String(valve.port_a_T, "g"));
 */
void PipesValveDiscrete_eqFunction_369(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,369};
  modelica_boolean tmp483;
  modelica_boolean tmp484;
  static const MMC_DEFSTRINGLIT(tmp485,115,"Variable valve.port_a_T out of [min, max] interval: valve.port_a_T >= 1.0 and valve.port_a_T <= 10000.0 has value: ");
  modelica_string tmp486;
  static int tmp487 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp487)
  {
    tmp483 = GreaterEq($Pvalve$Pport_a_T,1.0);
    tmp484 = LessEq($Pvalve$Pport_a_T,10000.0);
    if(!(tmp483 && tmp484))
    {
      tmp486 = modelica_real_to_modelica_string_format($Pvalve$Pport_a_T, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp485),tmp486);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",345,3,350,54,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.port_a_T >= 1.0 and valve.port_a_T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp487 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 370
 type: ALGORITHM
 
   assert(valve.port_b_T >= 1.0 and valve.port_b_T <= 10000.0, "Variable valve.port_b_T out of [min, max] interval: valve.port_b_T >= 1.0 and valve.port_b_T <= 10000.0 has value: " + String(valve.port_b_T, "g"));
 */
void PipesValveDiscrete_eqFunction_370(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,370};
  modelica_boolean tmp488;
  modelica_boolean tmp489;
  static const MMC_DEFSTRINGLIT(tmp490,115,"Variable valve.port_b_T out of [min, max] interval: valve.port_b_T >= 1.0 and valve.port_b_T <= 10000.0 has value: ");
  modelica_string tmp491;
  static int tmp492 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp492)
  {
    tmp488 = GreaterEq($Pvalve$Pport_b_T,1.0);
    tmp489 = LessEq($Pvalve$Pport_b_T,10000.0);
    if(!(tmp488 && tmp489))
    {
      tmp491 = modelica_real_to_modelica_string_format($Pvalve$Pport_b_T, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp490),tmp491);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",351,3,356,54,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.port_b_T >= 1.0 and valve.port_b_T <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp492 = 1;
    }
  }
  TRACE_POP
}
/* function to check assert after a step is done */
int PipesValveDiscrete_checkForAsserts(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH

  PipesValveDiscrete_eqFunction_337(data, threadData);

  PipesValveDiscrete_eqFunction_338(data, threadData);

  PipesValveDiscrete_eqFunction_339(data, threadData);

  PipesValveDiscrete_eqFunction_340(data, threadData);

  PipesValveDiscrete_eqFunction_341(data, threadData);

  PipesValveDiscrete_eqFunction_342(data, threadData);

  PipesValveDiscrete_eqFunction_343(data, threadData);

  PipesValveDiscrete_eqFunction_344(data, threadData);

  PipesValveDiscrete_eqFunction_345(data, threadData);

  PipesValveDiscrete_eqFunction_346(data, threadData);

  PipesValveDiscrete_eqFunction_347(data, threadData);

  PipesValveDiscrete_eqFunction_348(data, threadData);

  PipesValveDiscrete_eqFunction_349(data, threadData);

  PipesValveDiscrete_eqFunction_350(data, threadData);

  PipesValveDiscrete_eqFunction_351(data, threadData);

  PipesValveDiscrete_eqFunction_352(data, threadData);

  PipesValveDiscrete_eqFunction_353(data, threadData);

  PipesValveDiscrete_eqFunction_354(data, threadData);

  PipesValveDiscrete_eqFunction_355(data, threadData);

  PipesValveDiscrete_eqFunction_356(data, threadData);

  PipesValveDiscrete_eqFunction_357(data, threadData);

  PipesValveDiscrete_eqFunction_358(data, threadData);

  PipesValveDiscrete_eqFunction_359(data, threadData);

  PipesValveDiscrete_eqFunction_360(data, threadData);

  PipesValveDiscrete_eqFunction_361(data, threadData);

  PipesValveDiscrete_eqFunction_362(data, threadData);

  PipesValveDiscrete_eqFunction_363(data, threadData);

  PipesValveDiscrete_eqFunction_364(data, threadData);

  PipesValveDiscrete_eqFunction_365(data, threadData);

  PipesValveDiscrete_eqFunction_366(data, threadData);

  PipesValveDiscrete_eqFunction_367(data, threadData);

  PipesValveDiscrete_eqFunction_368(data, threadData);

  PipesValveDiscrete_eqFunction_369(data, threadData);

  PipesValveDiscrete_eqFunction_370(data, threadData);
  
  TRACE_POP
  return 0;
}

#if defined(__cplusplus)
}
#endif

