/* update bound parameters and variable attributes (start, nominal, min, max) */
/* Simulation code for PipesValveDiscrete generated by the OpenModelica Compiler OpenModelica 1.9.3. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "PipesValveDiscrete_functions.h"
#include "PipesValveDiscrete_model.h"
#include "PipesValveDiscrete_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 224
 type: SIMPLE_ASSIGN
 valve._dp = valve.dp_start
 */
void PipesValveDiscrete_eqFunction_224(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,224};
  $Pvalve$Pdp = $Pvalve$Pdp_start;
  TRACE_POP
}
/*
 equation index: 225
 type: SIMPLE_ASSIGN
 tank2._medium._T = tank2.T_start
 */
void PipesValveDiscrete_eqFunction_225(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,225};
  $Ptank2$Pmedium$PT = $Ptank2$PT_start;
  TRACE_POP
}
/*
 equation index: 226
 type: SIMPLE_ASSIGN
 tank2._ports[1]._h_outflow = tank2.h_start
 */
void PipesValveDiscrete_eqFunction_226(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,226};
  $Ptank2$Pports$lB1$rB$Ph_outflow = $Ptank2$Ph_start;
  TRACE_POP
}
/*
 equation index: 227
 type: SIMPLE_ASSIGN
 pipe._flowModel._dps_fg[1] = pipe.flowModel.p_a_start - pipe.flowModel.p_b_start
 */
void PipesValveDiscrete_eqFunction_227(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,227};
  $Ppipe$PflowModel$Pdps_fg$lB1$rB = ($Ppipe$PflowModel$Pp_a_start - $Ppipe$PflowModel$Pp_b_start);
  TRACE_POP
}
/*
 equation index: 228
 type: SIMPLE_ASSIGN
 tank1._medium._T = tank1.T_start
 */
void PipesValveDiscrete_eqFunction_228(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,228};
  $Ptank1$Pmedium$PT = $Ptank1$PT_start;
  TRACE_POP
}
/*
 equation index: 229
 type: SIMPLE_ASSIGN
 tank1._ports[1]._h_outflow = tank1.h_start
 */
void PipesValveDiscrete_eqFunction_229(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,229};
  $Ptank1$Pports$lB1$rB$Ph_outflow = $Ptank1$Ph_start;
  TRACE_POP
}
int PipesValveDiscrete_updateBoundVariableAttributes(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  /* min ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating min-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* max ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating max-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* nominal **************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating nominal-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* start ****************************************************** */
  PipesValveDiscrete_eqFunction_224(data, threadData);

  PipesValveDiscrete_eqFunction_225(data, threadData);

  PipesValveDiscrete_eqFunction_226(data, threadData);

  PipesValveDiscrete_eqFunction_227(data, threadData);

  PipesValveDiscrete_eqFunction_228(data, threadData);

  PipesValveDiscrete_eqFunction_229(data, threadData);
  
  infoStreamPrint(LOG_INIT, 1, "updating start-values");
  $P$ATTRIBUTE$Pvalve$Pdp.start = $Pvalve$Pdp;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $Pvalve$Pdp__varInfo.name, (modelica_real)  $P$ATTRIBUTE$Pvalve$Pdp.start);
  $P$ATTRIBUTE$Ptank2$Pmedium$PT.start = $Ptank2$Pmedium$PT;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $Ptank2$Pmedium$PT__varInfo.name, (modelica_real)  $P$ATTRIBUTE$Ptank2$Pmedium$PT.start);
  $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Ph_outflow.start = $Ptank2$Pports$lB1$rB$Ph_outflow;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $Ptank2$Pports$lB1$rB$Ph_outflow__varInfo.name, (modelica_real)  $P$ATTRIBUTE$Ptank2$Pports$lB1$rB$Ph_outflow.start);
  $P$ATTRIBUTE$Ppipe$PflowModel$Pdps_fg$lB1$rB.start = $Ppipe$PflowModel$Pdps_fg$lB1$rB;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $Ppipe$PflowModel$Pdps_fg$lB1$rB__varInfo.name, (modelica_real)  $P$ATTRIBUTE$Ppipe$PflowModel$Pdps_fg$lB1$rB.start);
  $P$ATTRIBUTE$Ptank1$Pmedium$PT.start = $Ptank1$Pmedium$PT;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $Ptank1$Pmedium$PT__varInfo.name, (modelica_real)  $P$ATTRIBUTE$Ptank1$Pmedium$PT.start);
  $P$ATTRIBUTE$Ptank1$Pports$lB1$rB$Ph_outflow.start = $Ptank1$Pports$lB1$rB$Ph_outflow;
    infoStreamPrint(LOG_INIT, 0, "%s(start=%g)", $Ptank1$Pports$lB1$rB$Ph_outflow__varInfo.name, (modelica_real)  $P$ATTRIBUTE$Ptank1$Pports$lB1$rB$Ph_outflow.start);
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  TRACE_POP
  return 0;
}


/*
 equation index: 230
 type: SIMPLE_ASSIGN
 tank1._m_flow_nominal = 100.0 * system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_230(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,230};
  $Ptank1$Pm_flow_nominal = (100.0 * $Psystem$Pm_flow_small);
  TRACE_POP
}
/*
 equation index: 231
 type: SIMPLE_ASSIGN
 tank1._m_flow_small = system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_231(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,231};
  $Ptank1$Pm_flow_small = $Psystem$Pm_flow_small;
  TRACE_POP
}
/*
 equation index: 232
 type: SIMPLE_ASSIGN
 tank1._p_ambient = system.p_ambient
 */
void PipesValveDiscrete_eqFunction_232(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,232};
  $Ptank1$Pp_ambient = $Psystem$Pp_ambient;
  TRACE_POP
}
/*
 equation index: 233
 type: SIMPLE_ASSIGN
 tank1._T_ambient = system.T_ambient
 */
void PipesValveDiscrete_eqFunction_233(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,233};
  $Ptank1$PT_ambient = $Psystem$PT_ambient;
  TRACE_POP
}
/*
 equation index: 234
 type: SIMPLE_ASSIGN
 system._T_start = system.T_ambient
 */
void PipesValveDiscrete_eqFunction_234(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,234};
  $Psystem$PT_start = $Psystem$PT_ambient;
  TRACE_POP
}
/*
 equation index: 235
 type: SIMPLE_ASSIGN
 tank1._T_start = system.T_start
 */
void PipesValveDiscrete_eqFunction_235(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,235};
  $Ptank1$PT_start = $Psystem$PT_start;
  TRACE_POP
}
/*
 equation index: 236
 type: SIMPLE_ASSIGN
 tank1._p_start = tank1.p_ambient
 */
void PipesValveDiscrete_eqFunction_236(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,236};
  $Ptank1$Pp_start = $Ptank1$Pp_ambient;
  TRACE_POP
}
/*
 equation index: 237
 type: SIMPLE_ASSIGN
 tank1._h_start = Modelica.Fluid.Vessels.OpenTank$tank1.Medium.specificEnthalpy_pTX(tank1.p_start, tank1.T_start, {tank1.X_start[1]})
 */
void PipesValveDiscrete_eqFunction_237(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,237};
  real_array tmp0;
  array_alloc_scalar_real_array(&tmp0, 1, (modelica_real)$Ptank1$PX_start$lB1$rB);
  $Ptank1$Ph_start = omc_Modelica_Fluid_Vessels_OpenTank$tank1_Medium_specificEnthalpy__pTX(threadData, $Ptank1$Pp_start, $Ptank1$PT_start, tmp0);
  TRACE_POP
}
/*
 equation index: 238
 type: SIMPLE_ASSIGN
 tank1._heatTransfer._use_k = tank1.use_HeatTransfer
 */
void PipesValveDiscrete_eqFunction_238(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,238};
  $Ptank1$PheatTransfer$Puse_k = $Ptank1$Puse_HeatTransfer;
  TRACE_POP
}
/*
 equation index: 239
 type: SIMPLE_ASSIGN
 tank1._heatTransfer._T_ambient = system.T_ambient
 */
void PipesValveDiscrete_eqFunction_239(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,239};
  $Ptank1$PheatTransfer$PT_ambient = $Psystem$PT_ambient;
  TRACE_POP
}
/*
 equation index: 240
 type: SIMPLE_ASSIGN
 system._p_start = system.p_ambient
 */
void PipesValveDiscrete_eqFunction_240(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,240};
  $Psystem$Pp_start = $Psystem$Pp_ambient;
  TRACE_POP
}
/*
 equation index: 241
 type: SIMPLE_ASSIGN
 pipe._p_a_start = system.p_start
 */
void PipesValveDiscrete_eqFunction_241(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,241};
  $Ppipe$Pp_a_start = $Psystem$Pp_start;
  TRACE_POP
}
/*
 equation index: 242
 type: SIMPLE_ASSIGN
 pipe._crossArea = 0.7853981633974483 * pipe.diameter ^ 2.0
 */
void PipesValveDiscrete_eqFunction_242(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,242};
  modelica_real tmp1;
  tmp1 = $Ppipe$Pdiameter;
  $Ppipe$PcrossArea = (0.7853981633974483 * (tmp1 * tmp1));
  TRACE_POP
}
/*
 equation index: 243
 type: SIMPLE_ASSIGN
 pipe._perimeter = 3.141592653589793 * pipe.diameter
 */
void PipesValveDiscrete_eqFunction_243(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,243};
  $Ppipe$Pperimeter = (3.141592653589793 * $Ppipe$Pdiameter);
  TRACE_POP
}
/*
 equation index: 244
 type: SIMPLE_ASSIGN
 pipe._p_b_start = pipe.p_a_start
 */
void PipesValveDiscrete_eqFunction_244(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,244};
  $Ppipe$Pp_b_start = $Ppipe$Pp_a_start;
  TRACE_POP
}
/*
 equation index: 245
 type: SIMPLE_ASSIGN
 pipe._flowModel._nParallel = pipe.nParallel
 */
void PipesValveDiscrete_eqFunction_245(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,245};
  $Ppipe$PflowModel$PnParallel = $Ppipe$PnParallel;
  TRACE_POP
}
/*
 equation index: 246
 type: SIMPLE_ASSIGN
 pipe._flowModel._p_a_start = pipe.p_a_start
 */
void PipesValveDiscrete_eqFunction_246(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,246};
  $Ppipe$PflowModel$Pp_a_start = $Ppipe$Pp_a_start;
  TRACE_POP
}
/*
 equation index: 247
 type: SIMPLE_ASSIGN
 pipe._flowModel._p_b_start = pipe.p_b_start
 */
void PipesValveDiscrete_eqFunction_247(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,247};
  $Ppipe$PflowModel$Pp_b_start = $Ppipe$Pp_b_start;
  TRACE_POP
}
/*
 equation index: 248
 type: SIMPLE_ASSIGN
 pipe._flowModel._g = system.g
 */
void PipesValveDiscrete_eqFunction_248(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,248};
  $Ppipe$PflowModel$Pg = $Psystem$Pg;
  TRACE_POP
}
/*
 equation index: 249
 type: SIMPLE_ASSIGN
 pipe._flowModel._m_flow_small = system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_249(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,249};
  $Ppipe$PflowModel$Pm_flow_small = $Psystem$Pm_flow_small;
  TRACE_POP
}
/*
 equation index: 250
 type: SIMPLE_ASSIGN
 pipe._flowModel._m_flow_nominal = 100.0 * pipe.flowModel.m_flow_small
 */
void PipesValveDiscrete_eqFunction_250(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,250};
  $Ppipe$PflowModel$Pm_flow_nominal = (100.0 * $Ppipe$PflowModel$Pm_flow_small);
  TRACE_POP
}
/*
 equation index: 251
 type: SIMPLE_ASSIGN
 tank2._m_flow_nominal = 100.0 * system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_251(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,251};
  $Ptank2$Pm_flow_nominal = (100.0 * $Psystem$Pm_flow_small);
  TRACE_POP
}
/*
 equation index: 252
 type: SIMPLE_ASSIGN
 tank2._m_flow_small = system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_252(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,252};
  $Ptank2$Pm_flow_small = $Psystem$Pm_flow_small;
  TRACE_POP
}
/*
 equation index: 253
 type: SIMPLE_ASSIGN
 tank2._p_ambient = system.p_ambient
 */
void PipesValveDiscrete_eqFunction_253(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,253};
  $Ptank2$Pp_ambient = $Psystem$Pp_ambient;
  TRACE_POP
}
/*
 equation index: 254
 type: SIMPLE_ASSIGN
 tank2._T_ambient = system.T_ambient
 */
void PipesValveDiscrete_eqFunction_254(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,254};
  $Ptank2$PT_ambient = $Psystem$PT_ambient;
  TRACE_POP
}
/*
 equation index: 255
 type: SIMPLE_ASSIGN
 tank2._T_start = system.T_start
 */
void PipesValveDiscrete_eqFunction_255(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,255};
  $Ptank2$PT_start = $Psystem$PT_start;
  TRACE_POP
}
/*
 equation index: 256
 type: SIMPLE_ASSIGN
 tank2._p_start = tank2.p_ambient
 */
void PipesValveDiscrete_eqFunction_256(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,256};
  $Ptank2$Pp_start = $Ptank2$Pp_ambient;
  TRACE_POP
}
/*
 equation index: 257
 type: SIMPLE_ASSIGN
 tank2._h_start = Modelica.Fluid.Vessels.OpenTank$tank2.Medium.specificEnthalpy_pTX(tank2.p_start, tank2.T_start, {tank2.X_start[1]})
 */
void PipesValveDiscrete_eqFunction_257(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,257};
  real_array tmp2;
  array_alloc_scalar_real_array(&tmp2, 1, (modelica_real)$Ptank2$PX_start$lB1$rB);
  $Ptank2$Ph_start = omc_Modelica_Fluid_Vessels_OpenTank$tank2_Medium_specificEnthalpy__pTX(threadData, $Ptank2$Pp_start, $Ptank2$PT_start, tmp2);
  TRACE_POP
}
/*
 equation index: 258
 type: SIMPLE_ASSIGN
 tank2._heatTransfer._use_k = tank2.use_HeatTransfer
 */
void PipesValveDiscrete_eqFunction_258(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,258};
  $Ptank2$PheatTransfer$Puse_k = $Ptank2$Puse_HeatTransfer;
  TRACE_POP
}
/*
 equation index: 259
 type: SIMPLE_ASSIGN
 tank2._heatTransfer._T_ambient = system.T_ambient
 */
void PipesValveDiscrete_eqFunction_259(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,259};
  $Ptank2$PheatTransfer$PT_ambient = $Psystem$PT_ambient;
  TRACE_POP
}
/*
 equation index: 260
 type: SIMPLE_ASSIGN
 valve._dp_start = 0.01 * system.p_start
 */
void PipesValveDiscrete_eqFunction_260(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,260};
  $Pvalve$Pdp_start = (0.01 * $Psystem$Pp_start);
  TRACE_POP
}
/*
 equation index: 261
 type: SIMPLE_ASSIGN
 valve._m_flow_start = system.m_flow_start
 */
void PipesValveDiscrete_eqFunction_261(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,261};
  $Pvalve$Pm_flow_start = $Psystem$Pm_flow_start;
  TRACE_POP
}
/*
 equation index: 262
 type: SIMPLE_ASSIGN
 valve._m_flow_small = system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_262(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,262};
  $Pvalve$Pm_flow_small = $Psystem$Pm_flow_small;
  TRACE_POP
}
/*
 equation index: 263
 type: SIMPLE_ASSIGN
 valve._k = DIVISION(valve.m_flow_nominal, valve.dp_nominal)
 */
void PipesValveDiscrete_eqFunction_263(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,263};
  $Pvalve$Pk = DIVISION_SIM($Pvalve$Pm_flow_nominal,$Pvalve$Pdp_nominal,"valve.dp_nominal",equationIndexes);
  TRACE_POP
}
/*
 equation index: 264
 type: SIMPLE_ASSIGN
 system._m_flow_nominal = 100.0 * system.m_flow_small
 */
void PipesValveDiscrete_eqFunction_264(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,264};
  $Psystem$Pm_flow_nominal = (100.0 * $Psystem$Pm_flow_small);
  TRACE_POP
}
/*
 equation index: 265
 type: ALGORITHM
 
   assert(tank1.height >= 0.0, "Variable tank1.height out of [min, max] interval: tank1.height >= 0.0 has value: " + String(tank1.height, "g"));
 */
void PipesValveDiscrete_eqFunction_265(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,265};
  modelica_boolean tmp3;
  static const MMC_DEFSTRINGLIT(tmp4,81,"Variable tank1.height out of [min, max] interval: tank1.height >= 0.0 has value: ");
  modelica_string tmp5;
  static int tmp6 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp6)
  {
    tmp3 = GreaterEq($Ptank1$Pheight,0.0);
    if(!tmp3)
    {
      tmp5 = modelica_real_to_modelica_string_format($Ptank1$Pheight, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp4),tmp5);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",58,3,58,46,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.height >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp6 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 266
 type: ALGORITHM
 
   assert(tank1.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank1.energyDynamics out of [min, max] interval: tank1.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank1.energyDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_266(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,266};
  modelica_boolean tmp7;
  modelica_boolean tmp8;
  static const MMC_DEFSTRINGLIT(tmp9,212,"Variable tank1.energyDynamics out of [min, max] interval: tank1.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp10;
  static int tmp11 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp11)
  {
    tmp7 = GreaterEq((modelica_integer)$Ptank1$PenergyDynamics,1);
    tmp8 = LessEq((modelica_integer)$Ptank1$PenergyDynamics,4);
    if(!(tmp7 && tmp8))
    {
      tmp10 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank1$PenergyDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp9),tmp10);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",543,7,545,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp11 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 267
 type: ALGORITHM
 
   assert(tank1.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank1.massDynamics out of [min, max] interval: tank1.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank1.massDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_267(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,267};
  modelica_boolean tmp12;
  modelica_boolean tmp13;
  static const MMC_DEFSTRINGLIT(tmp14,206,"Variable tank1.massDynamics out of [min, max] interval: tank1.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp15;
  static int tmp16 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp16)
  {
    tmp12 = GreaterEq((modelica_integer)$Ptank1$PmassDynamics,1);
    tmp13 = LessEq((modelica_integer)$Ptank1$PmassDynamics,4);
    if(!(tmp12 && tmp13))
    {
      tmp15 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank1$PmassDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp14),tmp15);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",546,7,548,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp16 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 268
 type: ALGORITHM
 
   assert(system.m_flow_small >= 0.0, "Variable system.m_flow_small out of [min, max] interval: system.m_flow_small >= 0.0 has value: " + String(system.m_flow_small, "g"));
 */
void PipesValveDiscrete_eqFunction_268(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,268};
  modelica_boolean tmp17;
  static const MMC_DEFSTRINGLIT(tmp18,95,"Variable system.m_flow_small out of [min, max] interval: system.m_flow_small >= 0.0 has value: ");
  modelica_string tmp19;
  static int tmp20 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp20)
  {
    tmp17 = GreaterEq($Psystem$Pm_flow_small,0.0);
    if(!tmp17)
    {
      tmp19 = modelica_real_to_modelica_string_format($Psystem$Pm_flow_small, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp18),tmp19);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",63,3,65,83,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.m_flow_small >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp20 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 269
 type: ALGORITHM
 
   assert(tank1.m_flow_nominal >= -100000.0 and tank1.m_flow_nominal <= 100000.0, "Variable tank1.m_flow_nominal out of [min, max] interval: tank1.m_flow_nominal >= -100000.0 and tank1.m_flow_nominal <= 100000.0 has value: " + String(tank1.m_flow_nominal, "g"));
 */
void PipesValveDiscrete_eqFunction_269(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,269};
  modelica_boolean tmp21;
  modelica_boolean tmp22;
  static const MMC_DEFSTRINGLIT(tmp23,140,"Variable tank1.m_flow_nominal out of [min, max] interval: tank1.m_flow_nominal >= -100000.0 and tank1.m_flow_nominal <= 100000.0 has value: ");
  modelica_string tmp24;
  static int tmp25 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp25)
  {
    tmp21 = GreaterEq($Ptank1$Pm_flow_nominal,-100000.0);
    tmp22 = LessEq($Ptank1$Pm_flow_nominal,100000.0);
    if(!(tmp21 && tmp22))
    {
      tmp24 = modelica_real_to_modelica_string_format($Ptank1$Pm_flow_nominal, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp23),tmp24);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",210,9,212,110,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.m_flow_nominal >= -100000.0 and tank1.m_flow_nominal <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp25 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 270
 type: ALGORITHM
 
   assert(tank1.m_flow_small >= 0.0, "Variable tank1.m_flow_small out of [min, max] interval: tank1.m_flow_small >= 0.0 has value: " + String(tank1.m_flow_small, "g"));
 */
void PipesValveDiscrete_eqFunction_270(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,270};
  modelica_boolean tmp26;
  static const MMC_DEFSTRINGLIT(tmp27,93,"Variable tank1.m_flow_small out of [min, max] interval: tank1.m_flow_small >= 0.0 has value: ");
  modelica_string tmp28;
  static int tmp29 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp29)
  {
    tmp26 = GreaterEq($Ptank1$Pm_flow_small,0.0);
    if(!tmp26)
    {
      tmp28 = modelica_real_to_modelica_string_format($Ptank1$Pm_flow_small, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp27),tmp28);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",213,9,215,110,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.m_flow_small >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp29 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 271
 type: ALGORITHM
 
   assert(system.p_ambient >= 0.0, "Variable system.p_ambient out of [min, max] interval: system.p_ambient >= 0.0 has value: " + String(system.p_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_271(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,271};
  modelica_boolean tmp30;
  static const MMC_DEFSTRINGLIT(tmp31,89,"Variable system.p_ambient out of [min, max] interval: system.p_ambient >= 0.0 has value: ");
  modelica_string tmp32;
  static int tmp33 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp33)
  {
    tmp30 = GreaterEq($Psystem$Pp_ambient,0.0);
    if(!tmp30)
    {
      tmp32 = modelica_real_to_modelica_string_format($Psystem$Pp_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp31),tmp32);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",8,3,10,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.p_ambient >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp33 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 272
 type: ALGORITHM
 
   assert(tank1.p_ambient >= 0.0 and tank1.p_ambient <= 100000000.0, "Variable tank1.p_ambient out of [min, max] interval: tank1.p_ambient >= 0.0 and tank1.p_ambient <= 100000000.0 has value: " + String(tank1.p_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_272(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,272};
  modelica_boolean tmp34;
  modelica_boolean tmp35;
  static const MMC_DEFSTRINGLIT(tmp36,122,"Variable tank1.p_ambient out of [min, max] interval: tank1.p_ambient >= 0.0 and tank1.p_ambient <= 100000000.0 has value: ");
  modelica_string tmp37;
  static int tmp38 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp38)
  {
    tmp34 = GreaterEq($Ptank1$Pp_ambient,0.0);
    tmp35 = LessEq($Ptank1$Pp_ambient,100000000.0);
    if(!(tmp34 && tmp35))
    {
      tmp37 = modelica_real_to_modelica_string_format($Ptank1$Pp_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp36),tmp37);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",62,3,64,63,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.p_ambient >= 0.0 and tank1.p_ambient <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp38 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 273
 type: ALGORITHM
 
   assert(system.T_ambient >= 0.0, "Variable system.T_ambient out of [min, max] interval: system.T_ambient >= 0.0 has value: " + String(system.T_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_273(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,273};
  modelica_boolean tmp39;
  static const MMC_DEFSTRINGLIT(tmp40,89,"Variable system.T_ambient out of [min, max] interval: system.T_ambient >= 0.0 has value: ");
  modelica_string tmp41;
  static int tmp42 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp42)
  {
    tmp39 = GreaterEq($Psystem$PT_ambient,0.0);
    if(!tmp39)
    {
      tmp41 = modelica_real_to_modelica_string_format($Psystem$PT_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp40),tmp41);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",11,3,13,44,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.T_ambient >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp42 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 274
 type: ALGORITHM
 
   assert(tank1.T_ambient >= 1.0 and tank1.T_ambient <= 10000.0, "Variable tank1.T_ambient out of [min, max] interval: tank1.T_ambient >= 1.0 and tank1.T_ambient <= 10000.0 has value: " + String(tank1.T_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_274(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,274};
  modelica_boolean tmp43;
  modelica_boolean tmp44;
  static const MMC_DEFSTRINGLIT(tmp45,118,"Variable tank1.T_ambient out of [min, max] interval: tank1.T_ambient >= 1.0 and tank1.T_ambient <= 10000.0 has value: ");
  modelica_string tmp46;
  static int tmp47 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp47)
  {
    tmp43 = GreaterEq($Ptank1$PT_ambient,1.0);
    tmp44 = LessEq($Ptank1$PT_ambient,10000.0);
    if(!(tmp43 && tmp44))
    {
      tmp46 = modelica_real_to_modelica_string_format($Ptank1$PT_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp45),tmp46);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",65,3,67,63,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.T_ambient >= 1.0 and tank1.T_ambient <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp47 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 275
 type: ALGORITHM
 
   assert(tank1.X_start[1] >= 0.0 and tank1.X_start[1] <= 1.0, "Variable tank1.X_start[1] out of [min, max] interval: tank1.X_start[1] >= 0.0 and tank1.X_start[1] <= 1.0 has value: " + String(tank1.X_start[1], "g"));
 */
void PipesValveDiscrete_eqFunction_275(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,275};
  modelica_boolean tmp48;
  modelica_boolean tmp49;
  static const MMC_DEFSTRINGLIT(tmp50,117,"Variable tank1.X_start[1] out of [min, max] interval: tank1.X_start[1] >= 0.0 and tank1.X_start[1] <= 1.0 has value: ");
  modelica_string tmp51;
  static int tmp52 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp52)
  {
    tmp48 = GreaterEq($Ptank1$PX_start$lB1$rB,0.0);
    tmp49 = LessEq($Ptank1$PX_start$lB1$rB,1.0);
    if(!(tmp48 && tmp49))
    {
      tmp51 = modelica_real_to_modelica_string_format($Ptank1$PX_start$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp50),tmp51);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",571,7,573,73,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.X_start[1] >= 0.0 and tank1.X_start[1] <= 1.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp52 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 276
 type: ALGORITHM
 
   assert(system.T_start >= 0.0, "Variable system.T_start out of [min, max] interval: system.T_start >= 0.0 has value: " + String(system.T_start, "g"));
 */
void PipesValveDiscrete_eqFunction_276(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,276};
  modelica_boolean tmp53;
  static const MMC_DEFSTRINGLIT(tmp54,85,"Variable system.T_start out of [min, max] interval: system.T_start >= 0.0 has value: ");
  modelica_string tmp55;
  static int tmp56 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp56)
  {
    tmp53 = GreaterEq($Psystem$PT_start,0.0);
    if(!tmp53)
    {
      tmp55 = modelica_real_to_modelica_string_format($Psystem$PT_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp54),tmp55);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",47,3,49,47,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.T_start >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp56 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 277
 type: ALGORITHM
 
   assert(tank1.T_start >= 1.0 and tank1.T_start <= 10000.0, "Variable tank1.T_start out of [min, max] interval: tank1.T_start >= 1.0 and tank1.T_start <= 10000.0 has value: " + String(tank1.T_start, "g"));
 */
void PipesValveDiscrete_eqFunction_277(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,277};
  modelica_boolean tmp57;
  modelica_boolean tmp58;
  static const MMC_DEFSTRINGLIT(tmp59,112,"Variable tank1.T_start out of [min, max] interval: tank1.T_start >= 1.0 and tank1.T_start <= 10000.0 has value: ");
  modelica_string tmp60;
  static int tmp61 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp61)
  {
    tmp57 = GreaterEq($Ptank1$PT_start,1.0);
    tmp58 = LessEq($Ptank1$PT_start,10000.0);
    if(!(tmp57 && tmp58))
    {
      tmp60 = modelica_real_to_modelica_string_format($Ptank1$PT_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp59),tmp60);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",563,7,566,73,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.T_start >= 1.0 and tank1.T_start <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp61 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 278
 type: ALGORITHM
 
   assert(tank1.p_start >= 0.0 and tank1.p_start <= 100000000.0, "Variable tank1.p_start out of [min, max] interval: tank1.p_start >= 0.0 and tank1.p_start <= 100000000.0 has value: " + String(tank1.p_start, "g"));
 */
void PipesValveDiscrete_eqFunction_278(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,278};
  modelica_boolean tmp62;
  modelica_boolean tmp63;
  static const MMC_DEFSTRINGLIT(tmp64,116,"Variable tank1.p_start out of [min, max] interval: tank1.p_start >= 0.0 and tank1.p_start <= 100000000.0 has value: ");
  modelica_string tmp65;
  static int tmp66 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp66)
  {
    tmp62 = GreaterEq($Ptank1$Pp_start,0.0);
    tmp63 = LessEq($Ptank1$Pp_start,100000000.0);
    if(!(tmp62 && tmp63))
    {
      tmp65 = modelica_real_to_modelica_string_format($Ptank1$Pp_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp64),tmp65);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",557,7,559,51,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.p_start >= 0.0 and tank1.p_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp66 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 279
 type: ALGORITHM
 
   assert(tank1.h_start >= -10000000000.0 and tank1.h_start <= 10000000000.0, "Variable tank1.h_start out of [min, max] interval: tank1.h_start >= -10000000000.0 and tank1.h_start <= 10000000000.0 has value: " + String(tank1.h_start, "g"));
 */
void PipesValveDiscrete_eqFunction_279(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,279};
  modelica_boolean tmp67;
  modelica_boolean tmp68;
  static const MMC_DEFSTRINGLIT(tmp69,129,"Variable tank1.h_start out of [min, max] interval: tank1.h_start >= -10000000000.0 and tank1.h_start <= 10000000000.0 has value: ");
  modelica_string tmp70;
  static int tmp71 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp71)
  {
    tmp67 = GreaterEq($Ptank1$Ph_start,-10000000000.0);
    tmp68 = LessEq($Ptank1$Ph_start,10000000000.0);
    if(!(tmp67 && tmp68))
    {
      tmp70 = modelica_real_to_modelica_string_format($Ptank1$Ph_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp69),tmp70);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",567,7,570,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.h_start >= -10000000000.0 and tank1.h_start <= 10000000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp71 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 280
 type: ALGORITHM
 
   assert(tank1.portsData[1].diameter >= 0.0, "Variable tank1.portsData[1].diameter out of [min, max] interval: tank1.portsData[1].diameter >= 0.0 has value: " + String(tank1.portsData[1].diameter, "g"));
 */
void PipesValveDiscrete_eqFunction_280(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,280};
  modelica_boolean tmp72;
  static const MMC_DEFSTRINGLIT(tmp73,111,"Variable tank1.portsData[1].diameter out of [min, max] interval: tank1.portsData[1].diameter >= 0.0 has value: ");
  modelica_string tmp74;
  static int tmp75 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp75)
  {
    tmp72 = GreaterEq($Ptank1$PportsData$lB1$rB$Pdiameter,0.0);
    if(!tmp72)
    {
      tmp74 = modelica_real_to_modelica_string_format($Ptank1$PportsData$lB1$rB$Pdiameter, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp73),tmp74);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",546,7,547,58,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.portsData[1].diameter >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp75 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 281
 type: ALGORITHM
 
   assert(tank1.portsData[1].height >= 0.0, "Variable tank1.portsData[1].height out of [min, max] interval: tank1.portsData[1].height >= 0.0 has value: " + String(tank1.portsData[1].height, "g"));
 */
void PipesValveDiscrete_eqFunction_281(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,281};
  modelica_boolean tmp76;
  static const MMC_DEFSTRINGLIT(tmp77,107,"Variable tank1.portsData[1].height out of [min, max] interval: tank1.portsData[1].height >= 0.0 has value: ");
  modelica_string tmp78;
  static int tmp79 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp79)
  {
    tmp76 = GreaterEq($Ptank1$PportsData$lB1$rB$Pheight,0.0);
    if(!tmp76)
    {
      tmp78 = modelica_real_to_modelica_string_format($Ptank1$PportsData$lB1$rB$Pheight, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp77),tmp78);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",548,7,548,76,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.portsData[1].height >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp79 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 282
 type: ALGORITHM
 
   assert(tank1.portsData[1].zeta_out >= 0.0, "Variable tank1.portsData[1].zeta_out out of [min, max] interval: tank1.portsData[1].zeta_out >= 0.0 has value: " + String(tank1.portsData[1].zeta_out, "g"));
 */
void PipesValveDiscrete_eqFunction_282(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,282};
  modelica_boolean tmp80;
  static const MMC_DEFSTRINGLIT(tmp81,111,"Variable tank1.portsData[1].zeta_out out of [min, max] interval: tank1.portsData[1].zeta_out >= 0.0 has value: ");
  modelica_string tmp82;
  static int tmp83 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp83)
  {
    tmp80 = GreaterEq($Ptank1$PportsData$lB1$rB$Pzeta_out,0.0);
    if(!tmp80)
    {
      tmp82 = modelica_real_to_modelica_string_format($Ptank1$PportsData$lB1$rB$Pzeta_out, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp81),tmp82);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",549,7,550,105,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.portsData[1].zeta_out >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp83 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 283
 type: ALGORITHM
 
   assert(tank1.portsData[1].zeta_in >= 0.0, "Variable tank1.portsData[1].zeta_in out of [min, max] interval: tank1.portsData[1].zeta_in >= 0.0 has value: " + String(tank1.portsData[1].zeta_in, "g"));
 */
void PipesValveDiscrete_eqFunction_283(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,283};
  modelica_boolean tmp84;
  static const MMC_DEFSTRINGLIT(tmp85,109,"Variable tank1.portsData[1].zeta_in out of [min, max] interval: tank1.portsData[1].zeta_in >= 0.0 has value: ");
  modelica_string tmp86;
  static int tmp87 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp87)
  {
    tmp84 = GreaterEq($Ptank1$PportsData$lB1$rB$Pzeta_in,0.0);
    if(!tmp84)
    {
      tmp86 = modelica_real_to_modelica_string_format($Ptank1$PportsData$lB1$rB$Pzeta_in, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp85),tmp86);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",551,7,552,104,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.portsData[1].zeta_in >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp87 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 284
 type: ALGORITHM
 
   assert(tank1.fluidLevel_max >= 0.0, "Variable tank1.fluidLevel_max out of [min, max] interval: tank1.fluidLevel_max >= 0.0 has value: " + String(tank1.fluidLevel_max, "g"));
 */
void PipesValveDiscrete_eqFunction_284(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,284};
  modelica_boolean tmp88;
  static const MMC_DEFSTRINGLIT(tmp89,97,"Variable tank1.fluidLevel_max out of [min, max] interval: tank1.fluidLevel_max >= 0.0 has value: ");
  modelica_string tmp90;
  static int tmp91 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp91)
  {
    tmp88 = GreaterEq($Ptank1$PfluidLevel_max,0.0);
    if(!tmp88)
    {
      tmp90 = modelica_real_to_modelica_string_format($Ptank1$PfluidLevel_max, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp89),tmp90);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",276,9,277,47,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.fluidLevel_max >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp91 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 285
 type: ALGORITHM
 
   assert(tank1.level_start >= 0.0, "Variable tank1.level_start out of [min, max] interval: tank1.level_start >= 0.0 has value: " + String(tank1.level_start, "g"));
 */
void PipesValveDiscrete_eqFunction_285(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,285};
  modelica_boolean tmp92;
  static const MMC_DEFSTRINGLIT(tmp93,91,"Variable tank1.level_start out of [min, max] interval: tank1.level_start >= 0.0 has value: ");
  modelica_string tmp94;
  static int tmp95 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp95)
  {
    tmp92 = GreaterEq($Ptank1$Plevel_start,0.0);
    if(!tmp92)
    {
      tmp94 = modelica_real_to_modelica_string_format($Ptank1$Plevel_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp93),tmp94);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",70,3,72,45,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.level_start >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp95 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 286
 type: ALGORITHM
 
   assert(tank1.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank1.substanceDynamics out of [min, max] interval: tank1.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank1.substanceDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_286(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,286};
  modelica_boolean tmp96;
  modelica_boolean tmp97;
  static const MMC_DEFSTRINGLIT(tmp98,221,"Variable tank1.substanceDynamics out of [min, max] interval: tank1.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp99;
  static int tmp100 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp100)
  {
    tmp96 = GreaterEq((modelica_integer)$Ptank1$PsubstanceDynamics,1);
    tmp97 = LessEq((modelica_integer)$Ptank1$PsubstanceDynamics,4);
    if(!(tmp96 && tmp97))
    {
      tmp99 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank1$PsubstanceDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp98),tmp99);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",549,7,551,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp100 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 287
 type: ALGORITHM
 
   assert(tank1.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank1.traceDynamics out of [min, max] interval: tank1.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank1.traceDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_287(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,287};
  modelica_boolean tmp101;
  modelica_boolean tmp102;
  static const MMC_DEFSTRINGLIT(tmp103,209,"Variable tank1.traceDynamics out of [min, max] interval: tank1.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp104;
  static int tmp105 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp105)
  {
    tmp101 = GreaterEq((modelica_integer)$Ptank1$PtraceDynamics,1);
    tmp102 = LessEq((modelica_integer)$Ptank1$PtraceDynamics,4);
    if(!(tmp101 && tmp102))
    {
      tmp104 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank1$PtraceDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp103),tmp104);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",552,7,554,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank1.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp105 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 288
 type: ALGORITHM
 
   assert(tank1.level_start_eps >= 0.0, "Variable tank1.level_start_eps out of [min, max] interval: tank1.level_start_eps >= 0.0 has value: " + String(tank1.level_start_eps, "g"));
 */
void PipesValveDiscrete_eqFunction_288(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,288};
  modelica_boolean tmp106;
  static const MMC_DEFSTRINGLIT(tmp107,99,"Variable tank1.level_start_eps out of [min, max] interval: tank1.level_start_eps >= 0.0 has value: ");
  modelica_string tmp108;
  static int tmp109 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp109)
  {
    tmp106 = GreaterEq($Ptank1$Plevel_start_eps,0.0);
    if(!tmp106)
    {
      tmp108 = modelica_real_to_modelica_string_format($Ptank1$Plevel_start_eps, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp107),tmp108);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",85,3,85,87,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.level_start_eps >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp109 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 289
 type: ALGORITHM
 
   assert(tank1.heatTransfer.T_ambient >= 0.0, "Variable tank1.heatTransfer.T_ambient out of [min, max] interval: tank1.heatTransfer.T_ambient >= 0.0 has value: " + String(tank1.heatTransfer.T_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_289(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,289};
  modelica_boolean tmp110;
  static const MMC_DEFSTRINGLIT(tmp111,113,"Variable tank1.heatTransfer.T_ambient out of [min, max] interval: tank1.heatTransfer.T_ambient >= 0.0 has value: ");
  modelica_string tmp112;
  static int tmp113 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp113)
  {
    tmp110 = GreaterEq($Ptank1$PheatTransfer$PT_ambient,0.0);
    if(!tmp110)
    {
      tmp112 = modelica_real_to_modelica_string_format($Ptank1$PheatTransfer$PT_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp111),tmp112);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",492,5,493,42,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank1.heatTransfer.T_ambient >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp113 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 290
 type: ALGORITHM
 
   assert(pipe.nParallel >= 1.0, "Variable pipe.nParallel out of [min, max] interval: pipe.nParallel >= 1.0 has value: " + String(pipe.nParallel, "g"));
 */
void PipesValveDiscrete_eqFunction_290(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,290};
  modelica_boolean tmp114;
  static const MMC_DEFSTRINGLIT(tmp115,85,"Variable pipe.nParallel out of [min, max] interval: pipe.nParallel >= 1.0 has value: ");
  modelica_string tmp116;
  static int tmp117 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp117)
  {
    tmp114 = GreaterEq($Ppipe$PnParallel,1.0);
    if(!tmp114)
    {
      tmp116 = modelica_real_to_modelica_string_format($Ppipe$PnParallel, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp115),tmp116);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",248,7,249,45,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.nParallel >= 1.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp117 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 291
 type: ALGORITHM
 
   assert(pipe.diameter >= 0.0, "Variable pipe.diameter out of [min, max] interval: pipe.diameter >= 0.0 has value: " + String(pipe.diameter, "g"));
 */
void PipesValveDiscrete_eqFunction_291(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,291};
  modelica_boolean tmp118;
  static const MMC_DEFSTRINGLIT(tmp119,83,"Variable pipe.diameter out of [min, max] interval: pipe.diameter >= 0.0 has value: ");
  modelica_string tmp120;
  static int tmp121 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp121)
  {
    tmp118 = GreaterEq($Ppipe$Pdiameter,0.0);
    if(!tmp118)
    {
      tmp120 = modelica_real_to_modelica_string_format($Ppipe$Pdiameter, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp119),tmp120);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",255,7,256,64,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.diameter >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp121 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 292
 type: ALGORITHM
 
   assert(pipe.roughness >= 0.0, "Variable pipe.roughness out of [min, max] interval: pipe.roughness >= 0.0 has value: " + String(pipe.roughness, "g"));
 */
void PipesValveDiscrete_eqFunction_292(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,292};
  modelica_boolean tmp122;
  static const MMC_DEFSTRINGLIT(tmp123,85,"Variable pipe.roughness out of [min, max] interval: pipe.roughness >= 0.0 has value: ");
  modelica_string tmp124;
  static int tmp125 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp125)
  {
    tmp122 = GreaterEq($Ppipe$Proughness,0.0);
    if(!tmp122)
    {
      tmp124 = modelica_real_to_modelica_string_format($Ppipe$Proughness, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp123),tmp124);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",263,7,265,47,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.roughness >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp125 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 293
 type: ALGORITHM
 
   assert(system.p_start >= 0.0, "Variable system.p_start out of [min, max] interval: system.p_start >= 0.0 has value: " + String(system.p_start, "g"));
 */
void PipesValveDiscrete_eqFunction_293(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,293};
  modelica_boolean tmp126;
  static const MMC_DEFSTRINGLIT(tmp127,85,"Variable system.p_start out of [min, max] interval: system.p_start >= 0.0 has value: ");
  modelica_string tmp128;
  static int tmp129 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp129)
  {
    tmp126 = GreaterEq($Psystem$Pp_start,0.0);
    if(!tmp126)
    {
      tmp128 = modelica_real_to_modelica_string_format($Psystem$Pp_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp127),tmp128);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",44,3,46,47,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.p_start >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp129 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 294
 type: ALGORITHM
 
   assert(pipe.p_a_start >= 0.0 and pipe.p_a_start <= 100000000.0, "Variable pipe.p_a_start out of [min, max] interval: pipe.p_a_start >= 0.0 and pipe.p_a_start <= 100000000.0 has value: " + String(pipe.p_a_start, "g"));
 */
void PipesValveDiscrete_eqFunction_294(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,294};
  modelica_boolean tmp130;
  modelica_boolean tmp131;
  static const MMC_DEFSTRINGLIT(tmp132,119,"Variable pipe.p_a_start out of [min, max] interval: pipe.p_a_start >= 0.0 and pipe.p_a_start <= 100000000.0 has value: ");
  modelica_string tmp133;
  static int tmp134 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp134)
  {
    tmp130 = GreaterEq($Ppipe$Pp_a_start,0.0);
    tmp131 = LessEq($Ppipe$Pp_a_start,100000000.0);
    if(!(tmp130 && tmp131))
    {
      tmp133 = modelica_real_to_modelica_string_format($Ppipe$Pp_a_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp132),tmp133);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",11,5,13,49,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.p_a_start >= 0.0 and pipe.p_a_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp134 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 295
 type: ALGORITHM
 
   assert(pipe.m_flow_start >= -100000.0 and pipe.m_flow_start <= 100000.0, "Variable pipe.m_flow_start out of [min, max] interval: pipe.m_flow_start >= -100000.0 and pipe.m_flow_start <= 100000.0 has value: " + String(pipe.m_flow_start, "g"));
 */
void PipesValveDiscrete_eqFunction_295(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,295};
  modelica_boolean tmp135;
  modelica_boolean tmp136;
  static const MMC_DEFSTRINGLIT(tmp137,131,"Variable pipe.m_flow_start out of [min, max] interval: pipe.m_flow_start >= -100000.0 and pipe.m_flow_start <= 100000.0 has value: ");
  modelica_string tmp138;
  static int tmp139 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp139)
  {
    tmp135 = GreaterEq($Ppipe$Pm_flow_start,-100000.0);
    tmp136 = LessEq($Ppipe$Pm_flow_start,100000.0);
    if(!(tmp135 && tmp136))
    {
      tmp138 = modelica_real_to_modelica_string_format($Ppipe$Pm_flow_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp137),tmp138);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",17,5,19,65,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.m_flow_start >= -100000.0 and pipe.m_flow_start <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp139 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 296
 type: ALGORITHM
 
   assert(pipe.p_b_start >= 0.0 and pipe.p_b_start <= 100000000.0, "Variable pipe.p_b_start out of [min, max] interval: pipe.p_b_start >= 0.0 and pipe.p_b_start <= 100000000.0 has value: " + String(pipe.p_b_start, "g"));
 */
void PipesValveDiscrete_eqFunction_296(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,296};
  modelica_boolean tmp140;
  modelica_boolean tmp141;
  static const MMC_DEFSTRINGLIT(tmp142,119,"Variable pipe.p_b_start out of [min, max] interval: pipe.p_b_start >= 0.0 and pipe.p_b_start <= 100000000.0 has value: ");
  modelica_string tmp143;
  static int tmp144 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp144)
  {
    tmp140 = GreaterEq($Ppipe$Pp_b_start,0.0);
    tmp141 = LessEq($Ppipe$Pp_b_start,100000000.0);
    if(!(tmp140 && tmp141))
    {
      tmp143 = modelica_real_to_modelica_string_format($Ppipe$Pp_b_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp142),tmp143);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",14,5,16,49,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.p_b_start >= 0.0 and pipe.p_b_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp144 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 297
 type: ALGORITHM
 
   assert(pipe.flowModel.p_a_start >= 0.0 and pipe.flowModel.p_a_start <= 100000000.0, "Variable pipe.flowModel.p_a_start out of [min, max] interval: pipe.flowModel.p_a_start >= 0.0 and pipe.flowModel.p_a_start <= 100000000.0 has value: " + String(pipe.flowModel.p_a_start, "g"));
 */
void PipesValveDiscrete_eqFunction_297(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,297};
  modelica_boolean tmp145;
  modelica_boolean tmp146;
  static const MMC_DEFSTRINGLIT(tmp147,149,"Variable pipe.flowModel.p_a_start out of [min, max] interval: pipe.flowModel.p_a_start >= 0.0 and pipe.flowModel.p_a_start <= 100000000.0 has value: ");
  modelica_string tmp148;
  static int tmp149 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp149)
  {
    tmp145 = GreaterEq($Ppipe$PflowModel$Pp_a_start,0.0);
    tmp146 = LessEq($Ppipe$PflowModel$Pp_a_start,100000000.0);
    if(!(tmp145 && tmp146))
    {
      tmp148 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pp_a_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp147),tmp148);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1029,13,1031,97,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.p_a_start >= 0.0 and pipe.flowModel.p_a_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp149 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 298
 type: ALGORITHM
 
   assert(pipe.flowModel.p_b_start >= 0.0 and pipe.flowModel.p_b_start <= 100000000.0, "Variable pipe.flowModel.p_b_start out of [min, max] interval: pipe.flowModel.p_b_start >= 0.0 and pipe.flowModel.p_b_start <= 100000000.0 has value: " + String(pipe.flowModel.p_b_start, "g"));
 */
void PipesValveDiscrete_eqFunction_298(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,298};
  modelica_boolean tmp150;
  modelica_boolean tmp151;
  static const MMC_DEFSTRINGLIT(tmp152,149,"Variable pipe.flowModel.p_b_start out of [min, max] interval: pipe.flowModel.p_b_start >= 0.0 and pipe.flowModel.p_b_start <= 100000000.0 has value: ");
  modelica_string tmp153;
  static int tmp154 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp154)
  {
    tmp150 = GreaterEq($Ppipe$PflowModel$Pp_b_start,0.0);
    tmp151 = LessEq($Ppipe$PflowModel$Pp_b_start,100000000.0);
    if(!(tmp150 && tmp151))
    {
      tmp153 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pp_b_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp152),tmp153);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1032,13,1034,97,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.p_b_start >= 0.0 and pipe.flowModel.p_b_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp154 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 299
 type: ALGORITHM
 
   assert(pipe.flowModel.rho_nominal >= 0.0, "Variable pipe.flowModel.rho_nominal out of [min, max] interval: pipe.flowModel.rho_nominal >= 0.0 has value: " + String(pipe.flowModel.rho_nominal, "g"));
 */
void PipesValveDiscrete_eqFunction_299(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,299};
  modelica_boolean tmp155;
  static const MMC_DEFSTRINGLIT(tmp156,109,"Variable pipe.flowModel.rho_nominal out of [min, max] interval: pipe.flowModel.rho_nominal >= 0.0 has value: ");
  modelica_string tmp157;
  static int tmp158 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp158)
  {
    tmp155 = GreaterEq($Ppipe$PflowModel$Prho_nominal,0.0);
    if(!tmp155)
    {
      tmp157 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Prho_nominal, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp156),tmp157);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1080,13,1082,75,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.rho_nominal >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp158 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 300
 type: ALGORITHM
 
   assert(pipe.flowModel.mu_nominal >= 0.0, "Variable pipe.flowModel.mu_nominal out of [min, max] interval: pipe.flowModel.mu_nominal >= 0.0 has value: " + String(pipe.flowModel.mu_nominal, "g"));
 */
void PipesValveDiscrete_eqFunction_300(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,300};
  modelica_boolean tmp159;
  static const MMC_DEFSTRINGLIT(tmp160,107,"Variable pipe.flowModel.mu_nominal out of [min, max] interval: pipe.flowModel.mu_nominal >= 0.0 has value: ");
  modelica_string tmp161;
  static int tmp162 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp162)
  {
    tmp159 = GreaterEq($Ppipe$PflowModel$Pmu_nominal,0.0);
    if(!tmp159)
    {
      tmp161 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pmu_nominal, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp160),tmp161);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1087,13,1091,74,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.mu_nominal >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp162 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 301
 type: ALGORITHM
 
   assert(pipe.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and pipe.flowModel.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable pipe.flowModel.momentumDynamics out of [min, max] interval: pipe.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and pipe.flowModel.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(pipe.flowModel.momentumDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_301(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,301};
  modelica_boolean tmp163;
  modelica_boolean tmp164;
  static const MMC_DEFSTRINGLIT(tmp165,245,"Variable pipe.flowModel.momentumDynamics out of [min, max] interval: pipe.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and pipe.flowModel.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp166;
  static int tmp167 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp167)
  {
    tmp163 = GreaterEq((modelica_integer)$Ppipe$PflowModel$PmomentumDynamics,1);
    tmp164 = LessEq((modelica_integer)$Ppipe$PflowModel$PmomentumDynamics,4);
    if(!(tmp163 && tmp164))
    {
      tmp166 = modelica_integer_to_modelica_string_format((modelica_integer)$Ppipe$PflowModel$PmomentumDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp165),tmp166);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1021,13,1023,109,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and pipe.flowModel.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp167 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 302
 type: ALGORITHM
 
   assert(pipe.flowModel.m_flow_start >= -100000.0 and pipe.flowModel.m_flow_start <= 100000.0, "Variable pipe.flowModel.m_flow_start out of [min, max] interval: pipe.flowModel.m_flow_start >= -100000.0 and pipe.flowModel.m_flow_start <= 100000.0 has value: " + String(pipe.flowModel.m_flow_start, "g"));
 */
void PipesValveDiscrete_eqFunction_302(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,302};
  modelica_boolean tmp168;
  modelica_boolean tmp169;
  static const MMC_DEFSTRINGLIT(tmp170,161,"Variable pipe.flowModel.m_flow_start out of [min, max] interval: pipe.flowModel.m_flow_start >= -100000.0 and pipe.flowModel.m_flow_start <= 100000.0 has value: ");
  modelica_string tmp171;
  static int tmp172 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp172)
  {
    tmp168 = GreaterEq($Ppipe$PflowModel$Pm_flow_start,-100000.0);
    tmp169 = LessEq($Ppipe$PflowModel$Pm_flow_start,100000.0);
    if(!(tmp168 && tmp169))
    {
      tmp171 = modelica_real_to_modelica_string_format($Ppipe$PflowModel$Pm_flow_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp170),tmp171);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Pipes.mo",1026,13,1028,97,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\npipe.flowModel.m_flow_start >= -100000.0 and pipe.flowModel.m_flow_start <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp172 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 303
 type: ALGORITHM
 
   assert(tank2.height >= 0.0, "Variable tank2.height out of [min, max] interval: tank2.height >= 0.0 has value: " + String(tank2.height, "g"));
 */
void PipesValveDiscrete_eqFunction_303(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,303};
  modelica_boolean tmp173;
  static const MMC_DEFSTRINGLIT(tmp174,81,"Variable tank2.height out of [min, max] interval: tank2.height >= 0.0 has value: ");
  modelica_string tmp175;
  static int tmp176 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp176)
  {
    tmp173 = GreaterEq($Ptank2$Pheight,0.0);
    if(!tmp173)
    {
      tmp175 = modelica_real_to_modelica_string_format($Ptank2$Pheight, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp174),tmp175);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",58,3,58,46,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.height >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp176 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 304
 type: ALGORITHM
 
   assert(tank2.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank2.energyDynamics out of [min, max] interval: tank2.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank2.energyDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_304(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,304};
  modelica_boolean tmp177;
  modelica_boolean tmp178;
  static const MMC_DEFSTRINGLIT(tmp179,212,"Variable tank2.energyDynamics out of [min, max] interval: tank2.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp180;
  static int tmp181 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp181)
  {
    tmp177 = GreaterEq((modelica_integer)$Ptank2$PenergyDynamics,1);
    tmp178 = LessEq((modelica_integer)$Ptank2$PenergyDynamics,4);
    if(!(tmp177 && tmp178))
    {
      tmp180 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank2$PenergyDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp179),tmp180);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",543,7,545,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp181 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 305
 type: ALGORITHM
 
   assert(tank2.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank2.massDynamics out of [min, max] interval: tank2.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank2.massDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_305(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,305};
  modelica_boolean tmp182;
  modelica_boolean tmp183;
  static const MMC_DEFSTRINGLIT(tmp184,206,"Variable tank2.massDynamics out of [min, max] interval: tank2.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp185;
  static int tmp186 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp186)
  {
    tmp182 = GreaterEq((modelica_integer)$Ptank2$PmassDynamics,1);
    tmp183 = LessEq((modelica_integer)$Ptank2$PmassDynamics,4);
    if(!(tmp182 && tmp183))
    {
      tmp185 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank2$PmassDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp184),tmp185);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",546,7,548,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp186 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 306
 type: ALGORITHM
 
   assert(tank2.m_flow_nominal >= -100000.0 and tank2.m_flow_nominal <= 100000.0, "Variable tank2.m_flow_nominal out of [min, max] interval: tank2.m_flow_nominal >= -100000.0 and tank2.m_flow_nominal <= 100000.0 has value: " + String(tank2.m_flow_nominal, "g"));
 */
void PipesValveDiscrete_eqFunction_306(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,306};
  modelica_boolean tmp187;
  modelica_boolean tmp188;
  static const MMC_DEFSTRINGLIT(tmp189,140,"Variable tank2.m_flow_nominal out of [min, max] interval: tank2.m_flow_nominal >= -100000.0 and tank2.m_flow_nominal <= 100000.0 has value: ");
  modelica_string tmp190;
  static int tmp191 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp191)
  {
    tmp187 = GreaterEq($Ptank2$Pm_flow_nominal,-100000.0);
    tmp188 = LessEq($Ptank2$Pm_flow_nominal,100000.0);
    if(!(tmp187 && tmp188))
    {
      tmp190 = modelica_real_to_modelica_string_format($Ptank2$Pm_flow_nominal, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp189),tmp190);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",210,9,212,110,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.m_flow_nominal >= -100000.0 and tank2.m_flow_nominal <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp191 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 307
 type: ALGORITHM
 
   assert(tank2.m_flow_small >= 0.0, "Variable tank2.m_flow_small out of [min, max] interval: tank2.m_flow_small >= 0.0 has value: " + String(tank2.m_flow_small, "g"));
 */
void PipesValveDiscrete_eqFunction_307(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,307};
  modelica_boolean tmp192;
  static const MMC_DEFSTRINGLIT(tmp193,93,"Variable tank2.m_flow_small out of [min, max] interval: tank2.m_flow_small >= 0.0 has value: ");
  modelica_string tmp194;
  static int tmp195 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp195)
  {
    tmp192 = GreaterEq($Ptank2$Pm_flow_small,0.0);
    if(!tmp192)
    {
      tmp194 = modelica_real_to_modelica_string_format($Ptank2$Pm_flow_small, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp193),tmp194);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",213,9,215,110,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.m_flow_small >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp195 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 308
 type: ALGORITHM
 
   assert(tank2.p_ambient >= 0.0 and tank2.p_ambient <= 100000000.0, "Variable tank2.p_ambient out of [min, max] interval: tank2.p_ambient >= 0.0 and tank2.p_ambient <= 100000000.0 has value: " + String(tank2.p_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_308(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,308};
  modelica_boolean tmp196;
  modelica_boolean tmp197;
  static const MMC_DEFSTRINGLIT(tmp198,122,"Variable tank2.p_ambient out of [min, max] interval: tank2.p_ambient >= 0.0 and tank2.p_ambient <= 100000000.0 has value: ");
  modelica_string tmp199;
  static int tmp200 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp200)
  {
    tmp196 = GreaterEq($Ptank2$Pp_ambient,0.0);
    tmp197 = LessEq($Ptank2$Pp_ambient,100000000.0);
    if(!(tmp196 && tmp197))
    {
      tmp199 = modelica_real_to_modelica_string_format($Ptank2$Pp_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp198),tmp199);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",62,3,64,63,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.p_ambient >= 0.0 and tank2.p_ambient <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp200 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 309
 type: ALGORITHM
 
   assert(tank2.T_ambient >= 1.0 and tank2.T_ambient <= 10000.0, "Variable tank2.T_ambient out of [min, max] interval: tank2.T_ambient >= 1.0 and tank2.T_ambient <= 10000.0 has value: " + String(tank2.T_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_309(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,309};
  modelica_boolean tmp201;
  modelica_boolean tmp202;
  static const MMC_DEFSTRINGLIT(tmp203,118,"Variable tank2.T_ambient out of [min, max] interval: tank2.T_ambient >= 1.0 and tank2.T_ambient <= 10000.0 has value: ");
  modelica_string tmp204;
  static int tmp205 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp205)
  {
    tmp201 = GreaterEq($Ptank2$PT_ambient,1.0);
    tmp202 = LessEq($Ptank2$PT_ambient,10000.0);
    if(!(tmp201 && tmp202))
    {
      tmp204 = modelica_real_to_modelica_string_format($Ptank2$PT_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp203),tmp204);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",65,3,67,63,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.T_ambient >= 1.0 and tank2.T_ambient <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp205 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 310
 type: ALGORITHM
 
   assert(tank2.X_start[1] >= 0.0 and tank2.X_start[1] <= 1.0, "Variable tank2.X_start[1] out of [min, max] interval: tank2.X_start[1] >= 0.0 and tank2.X_start[1] <= 1.0 has value: " + String(tank2.X_start[1], "g"));
 */
void PipesValveDiscrete_eqFunction_310(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,310};
  modelica_boolean tmp206;
  modelica_boolean tmp207;
  static const MMC_DEFSTRINGLIT(tmp208,117,"Variable tank2.X_start[1] out of [min, max] interval: tank2.X_start[1] >= 0.0 and tank2.X_start[1] <= 1.0 has value: ");
  modelica_string tmp209;
  static int tmp210 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp210)
  {
    tmp206 = GreaterEq($Ptank2$PX_start$lB1$rB,0.0);
    tmp207 = LessEq($Ptank2$PX_start$lB1$rB,1.0);
    if(!(tmp206 && tmp207))
    {
      tmp209 = modelica_real_to_modelica_string_format($Ptank2$PX_start$lB1$rB, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp208),tmp209);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",571,7,573,73,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.X_start[1] >= 0.0 and tank2.X_start[1] <= 1.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp210 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 311
 type: ALGORITHM
 
   assert(tank2.T_start >= 1.0 and tank2.T_start <= 10000.0, "Variable tank2.T_start out of [min, max] interval: tank2.T_start >= 1.0 and tank2.T_start <= 10000.0 has value: " + String(tank2.T_start, "g"));
 */
void PipesValveDiscrete_eqFunction_311(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,311};
  modelica_boolean tmp211;
  modelica_boolean tmp212;
  static const MMC_DEFSTRINGLIT(tmp213,112,"Variable tank2.T_start out of [min, max] interval: tank2.T_start >= 1.0 and tank2.T_start <= 10000.0 has value: ");
  modelica_string tmp214;
  static int tmp215 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp215)
  {
    tmp211 = GreaterEq($Ptank2$PT_start,1.0);
    tmp212 = LessEq($Ptank2$PT_start,10000.0);
    if(!(tmp211 && tmp212))
    {
      tmp214 = modelica_real_to_modelica_string_format($Ptank2$PT_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp213),tmp214);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",563,7,566,73,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.T_start >= 1.0 and tank2.T_start <= 10000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp215 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 312
 type: ALGORITHM
 
   assert(tank2.p_start >= 0.0 and tank2.p_start <= 100000000.0, "Variable tank2.p_start out of [min, max] interval: tank2.p_start >= 0.0 and tank2.p_start <= 100000000.0 has value: " + String(tank2.p_start, "g"));
 */
void PipesValveDiscrete_eqFunction_312(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,312};
  modelica_boolean tmp216;
  modelica_boolean tmp217;
  static const MMC_DEFSTRINGLIT(tmp218,116,"Variable tank2.p_start out of [min, max] interval: tank2.p_start >= 0.0 and tank2.p_start <= 100000000.0 has value: ");
  modelica_string tmp219;
  static int tmp220 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp220)
  {
    tmp216 = GreaterEq($Ptank2$Pp_start,0.0);
    tmp217 = LessEq($Ptank2$Pp_start,100000000.0);
    if(!(tmp216 && tmp217))
    {
      tmp219 = modelica_real_to_modelica_string_format($Ptank2$Pp_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp218),tmp219);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",557,7,559,51,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.p_start >= 0.0 and tank2.p_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp220 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 313
 type: ALGORITHM
 
   assert(tank2.h_start >= -10000000000.0 and tank2.h_start <= 10000000000.0, "Variable tank2.h_start out of [min, max] interval: tank2.h_start >= -10000000000.0 and tank2.h_start <= 10000000000.0 has value: " + String(tank2.h_start, "g"));
 */
void PipesValveDiscrete_eqFunction_313(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,313};
  modelica_boolean tmp221;
  modelica_boolean tmp222;
  static const MMC_DEFSTRINGLIT(tmp223,129,"Variable tank2.h_start out of [min, max] interval: tank2.h_start >= -10000000000.0 and tank2.h_start <= 10000000000.0 has value: ");
  modelica_string tmp224;
  static int tmp225 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp225)
  {
    tmp221 = GreaterEq($Ptank2$Ph_start,-10000000000.0);
    tmp222 = LessEq($Ptank2$Ph_start,10000000000.0);
    if(!(tmp221 && tmp222))
    {
      tmp224 = modelica_real_to_modelica_string_format($Ptank2$Ph_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp223),tmp224);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",567,7,570,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.h_start >= -10000000000.0 and tank2.h_start <= 10000000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp225 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 314
 type: ALGORITHM
 
   assert(tank2.portsData[1].diameter >= 0.0, "Variable tank2.portsData[1].diameter out of [min, max] interval: tank2.portsData[1].diameter >= 0.0 has value: " + String(tank2.portsData[1].diameter, "g"));
 */
void PipesValveDiscrete_eqFunction_314(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,314};
  modelica_boolean tmp226;
  static const MMC_DEFSTRINGLIT(tmp227,111,"Variable tank2.portsData[1].diameter out of [min, max] interval: tank2.portsData[1].diameter >= 0.0 has value: ");
  modelica_string tmp228;
  static int tmp229 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp229)
  {
    tmp226 = GreaterEq($Ptank2$PportsData$lB1$rB$Pdiameter,0.0);
    if(!tmp226)
    {
      tmp228 = modelica_real_to_modelica_string_format($Ptank2$PportsData$lB1$rB$Pdiameter, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp227),tmp228);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",546,7,547,58,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.portsData[1].diameter >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp229 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 315
 type: ALGORITHM
 
   assert(tank2.portsData[1].height >= 0.0, "Variable tank2.portsData[1].height out of [min, max] interval: tank2.portsData[1].height >= 0.0 has value: " + String(tank2.portsData[1].height, "g"));
 */
void PipesValveDiscrete_eqFunction_315(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,315};
  modelica_boolean tmp230;
  static const MMC_DEFSTRINGLIT(tmp231,107,"Variable tank2.portsData[1].height out of [min, max] interval: tank2.portsData[1].height >= 0.0 has value: ");
  modelica_string tmp232;
  static int tmp233 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp233)
  {
    tmp230 = GreaterEq($Ptank2$PportsData$lB1$rB$Pheight,0.0);
    if(!tmp230)
    {
      tmp232 = modelica_real_to_modelica_string_format($Ptank2$PportsData$lB1$rB$Pheight, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp231),tmp232);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",548,7,548,76,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.portsData[1].height >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp233 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 316
 type: ALGORITHM
 
   assert(tank2.portsData[1].zeta_out >= 0.0, "Variable tank2.portsData[1].zeta_out out of [min, max] interval: tank2.portsData[1].zeta_out >= 0.0 has value: " + String(tank2.portsData[1].zeta_out, "g"));
 */
void PipesValveDiscrete_eqFunction_316(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,316};
  modelica_boolean tmp234;
  static const MMC_DEFSTRINGLIT(tmp235,111,"Variable tank2.portsData[1].zeta_out out of [min, max] interval: tank2.portsData[1].zeta_out >= 0.0 has value: ");
  modelica_string tmp236;
  static int tmp237 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp237)
  {
    tmp234 = GreaterEq($Ptank2$PportsData$lB1$rB$Pzeta_out,0.0);
    if(!tmp234)
    {
      tmp236 = modelica_real_to_modelica_string_format($Ptank2$PportsData$lB1$rB$Pzeta_out, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp235),tmp236);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",549,7,550,105,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.portsData[1].zeta_out >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp237 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 317
 type: ALGORITHM
 
   assert(tank2.portsData[1].zeta_in >= 0.0, "Variable tank2.portsData[1].zeta_in out of [min, max] interval: tank2.portsData[1].zeta_in >= 0.0 has value: " + String(tank2.portsData[1].zeta_in, "g"));
 */
void PipesValveDiscrete_eqFunction_317(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,317};
  modelica_boolean tmp238;
  static const MMC_DEFSTRINGLIT(tmp239,109,"Variable tank2.portsData[1].zeta_in out of [min, max] interval: tank2.portsData[1].zeta_in >= 0.0 has value: ");
  modelica_string tmp240;
  static int tmp241 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp241)
  {
    tmp238 = GreaterEq($Ptank2$PportsData$lB1$rB$Pzeta_in,0.0);
    if(!tmp238)
    {
      tmp240 = modelica_real_to_modelica_string_format($Ptank2$PportsData$lB1$rB$Pzeta_in, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp239),tmp240);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",551,7,552,104,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.portsData[1].zeta_in >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp241 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 318
 type: ALGORITHM
 
   assert(tank2.fluidLevel_max >= 0.0, "Variable tank2.fluidLevel_max out of [min, max] interval: tank2.fluidLevel_max >= 0.0 has value: " + String(tank2.fluidLevel_max, "g"));
 */
void PipesValveDiscrete_eqFunction_318(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,318};
  modelica_boolean tmp242;
  static const MMC_DEFSTRINGLIT(tmp243,97,"Variable tank2.fluidLevel_max out of [min, max] interval: tank2.fluidLevel_max >= 0.0 has value: ");
  modelica_string tmp244;
  static int tmp245 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp245)
  {
    tmp242 = GreaterEq($Ptank2$PfluidLevel_max,0.0);
    if(!tmp242)
    {
      tmp244 = modelica_real_to_modelica_string_format($Ptank2$PfluidLevel_max, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp243),tmp244);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",276,9,277,47,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.fluidLevel_max >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp245 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 319
 type: ALGORITHM
 
   assert(tank2.level_start >= 0.0, "Variable tank2.level_start out of [min, max] interval: tank2.level_start >= 0.0 has value: " + String(tank2.level_start, "g"));
 */
void PipesValveDiscrete_eqFunction_319(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,319};
  modelica_boolean tmp246;
  static const MMC_DEFSTRINGLIT(tmp247,91,"Variable tank2.level_start out of [min, max] interval: tank2.level_start >= 0.0 has value: ");
  modelica_string tmp248;
  static int tmp249 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp249)
  {
    tmp246 = GreaterEq($Ptank2$Plevel_start,0.0);
    if(!tmp246)
    {
      tmp248 = modelica_real_to_modelica_string_format($Ptank2$Plevel_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp247),tmp248);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",70,3,72,45,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.level_start >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp249 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 320
 type: ALGORITHM
 
   assert(tank2.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank2.substanceDynamics out of [min, max] interval: tank2.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank2.substanceDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_320(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,320};
  modelica_boolean tmp250;
  modelica_boolean tmp251;
  static const MMC_DEFSTRINGLIT(tmp252,221,"Variable tank2.substanceDynamics out of [min, max] interval: tank2.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp253;
  static int tmp254 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp254)
  {
    tmp250 = GreaterEq((modelica_integer)$Ptank2$PsubstanceDynamics,1);
    tmp251 = LessEq((modelica_integer)$Ptank2$PsubstanceDynamics,4);
    if(!(tmp250 && tmp251))
    {
      tmp253 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank2$PsubstanceDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp252),tmp253);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",549,7,551,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp254 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 321
 type: ALGORITHM
 
   assert(tank2.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable tank2.traceDynamics out of [min, max] interval: tank2.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(tank2.traceDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_321(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,321};
  modelica_boolean tmp255;
  modelica_boolean tmp256;
  static const MMC_DEFSTRINGLIT(tmp257,209,"Variable tank2.traceDynamics out of [min, max] interval: tank2.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp258;
  static int tmp259 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp259)
  {
    tmp255 = GreaterEq((modelica_integer)$Ptank2$PtraceDynamics,1);
    tmp256 = LessEq((modelica_integer)$Ptank2$PtraceDynamics,4);
    if(!(tmp255 && tmp256))
    {
      tmp258 = modelica_integer_to_modelica_string_format((modelica_integer)$Ptank2$PtraceDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp257),tmp258);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",552,7,554,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and tank2.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp259 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 322
 type: ALGORITHM
 
   assert(tank2.level_start_eps >= 0.0, "Variable tank2.level_start_eps out of [min, max] interval: tank2.level_start_eps >= 0.0 has value: " + String(tank2.level_start_eps, "g"));
 */
void PipesValveDiscrete_eqFunction_322(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,322};
  modelica_boolean tmp260;
  static const MMC_DEFSTRINGLIT(tmp261,99,"Variable tank2.level_start_eps out of [min, max] interval: tank2.level_start_eps >= 0.0 has value: ");
  modelica_string tmp262;
  static int tmp263 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp263)
  {
    tmp260 = GreaterEq($Ptank2$Plevel_start_eps,0.0);
    if(!tmp260)
    {
      tmp262 = modelica_real_to_modelica_string_format($Ptank2$Plevel_start_eps, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp261),tmp262);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Vessels.mo",85,3,85,87,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.level_start_eps >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp263 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 323
 type: ALGORITHM
 
   assert(tank2.heatTransfer.T_ambient >= 0.0, "Variable tank2.heatTransfer.T_ambient out of [min, max] interval: tank2.heatTransfer.T_ambient >= 0.0 has value: " + String(tank2.heatTransfer.T_ambient, "g"));
 */
void PipesValveDiscrete_eqFunction_323(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,323};
  modelica_boolean tmp264;
  static const MMC_DEFSTRINGLIT(tmp265,113,"Variable tank2.heatTransfer.T_ambient out of [min, max] interval: tank2.heatTransfer.T_ambient >= 0.0 has value: ");
  modelica_string tmp266;
  static int tmp267 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp267)
  {
    tmp264 = GreaterEq($Ptank2$PheatTransfer$PT_ambient,0.0);
    if(!tmp264)
    {
      tmp266 = modelica_real_to_modelica_string_format($Ptank2$PheatTransfer$PT_ambient, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp265),tmp266);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",492,5,493,42,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\ntank2.heatTransfer.T_ambient >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp267 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 324
 type: ALGORITHM
 
   assert(valve.dp_nominal >= 0.0, "Variable valve.dp_nominal out of [min, max] interval: valve.dp_nominal >= 0.0 has value: " + String(valve.dp_nominal, "g"));
 */
void PipesValveDiscrete_eqFunction_324(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,324};
  modelica_boolean tmp268;
  static const MMC_DEFSTRINGLIT(tmp269,89,"Variable valve.dp_nominal out of [min, max] interval: valve.dp_nominal >= 0.0 has value: ");
  modelica_string tmp270;
  static int tmp271 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp271)
  {
    tmp268 = GreaterEq($Pvalve$Pdp_nominal,0.0);
    if(!tmp268)
    {
      tmp270 = modelica_real_to_modelica_string_format($Pvalve$Pdp_nominal, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp269),tmp270);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Valves.mo",366,5,368,58,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.dp_nominal >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp271 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 325
 type: ALGORITHM
 
   assert(valve.m_flow_nominal >= -100000.0 and valve.m_flow_nominal <= 100000.0, "Variable valve.m_flow_nominal out of [min, max] interval: valve.m_flow_nominal >= -100000.0 and valve.m_flow_nominal <= 100000.0 has value: " + String(valve.m_flow_nominal, "g"));
 */
void PipesValveDiscrete_eqFunction_325(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,325};
  modelica_boolean tmp272;
  modelica_boolean tmp273;
  static const MMC_DEFSTRINGLIT(tmp274,140,"Variable valve.m_flow_nominal out of [min, max] interval: valve.m_flow_nominal >= -100000.0 and valve.m_flow_nominal <= 100000.0 has value: ");
  modelica_string tmp275;
  static int tmp276 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp276)
  {
    tmp272 = GreaterEq($Pvalve$Pm_flow_nominal,-100000.0);
    tmp273 = LessEq($Pvalve$Pm_flow_nominal,100000.0);
    if(!(tmp272 && tmp273))
    {
      tmp275 = modelica_real_to_modelica_string_format($Pvalve$Pm_flow_nominal, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp274),tmp275);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Valves.mo",369,5,370,48,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.m_flow_nominal >= -100000.0 and valve.m_flow_nominal <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp276 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 326
 type: ALGORITHM
 
   assert(valve.opening_min >= 0.0, "Variable valve.opening_min out of [min, max] interval: valve.opening_min >= 0.0 has value: " + String(valve.opening_min, "g"));
 */
void PipesValveDiscrete_eqFunction_326(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,326};
  modelica_boolean tmp277;
  static const MMC_DEFSTRINGLIT(tmp278,91,"Variable valve.opening_min out of [min, max] interval: valve.opening_min >= 0.0 has value: ");
  modelica_string tmp279;
  static int tmp280 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp280)
  {
    tmp277 = GreaterEq($Pvalve$Popening_min,0.0);
    if(!tmp277)
    {
      tmp279 = modelica_real_to_modelica_string_format($Pvalve$Popening_min, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp278),tmp279);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Valves.mo",378,5,379,64,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.opening_min >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp280 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 327
 type: ALGORITHM
 
   assert(valve.dp_start >= -9.999999999999999e+59 and valve.dp_start <= 100000000.0, "Variable valve.dp_start out of [min, max] interval: valve.dp_start >= -9.999999999999999e+59 and valve.dp_start <= 100000000.0 has value: " + String(valve.dp_start, "g"));
 */
void PipesValveDiscrete_eqFunction_327(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,327};
  modelica_boolean tmp281;
  modelica_boolean tmp282;
  static const MMC_DEFSTRINGLIT(tmp283,138,"Variable valve.dp_start out of [min, max] interval: valve.dp_start >= -9.999999999999999e+59 and valve.dp_start <= 100000000.0 has value: ");
  modelica_string tmp284;
  static int tmp285 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp285)
  {
    tmp281 = GreaterEq($Pvalve$Pdp_start,-9.999999999999999e+59);
    tmp282 = LessEq($Pvalve$Pdp_start,100000000.0);
    if(!(tmp281 && tmp282))
    {
      tmp284 = modelica_real_to_modelica_string_format($Pvalve$Pdp_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp283),tmp284);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",312,3,314,57,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.dp_start >= -9.999999999999999e+59 and valve.dp_start <= 100000000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp285 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 328
 type: ALGORITHM
 
   assert(valve.m_flow_start >= -100000.0 and valve.m_flow_start <= 100000.0, "Variable valve.m_flow_start out of [min, max] interval: valve.m_flow_start >= -100000.0 and valve.m_flow_start <= 100000.0 has value: " + String(valve.m_flow_start, "g"));
 */
void PipesValveDiscrete_eqFunction_328(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,328};
  modelica_boolean tmp286;
  modelica_boolean tmp287;
  static const MMC_DEFSTRINGLIT(tmp288,134,"Variable valve.m_flow_start out of [min, max] interval: valve.m_flow_start >= -100000.0 and valve.m_flow_start <= 100000.0 has value: ");
  modelica_string tmp289;
  static int tmp290 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp290)
  {
    tmp286 = GreaterEq($Pvalve$Pm_flow_start,-100000.0);
    tmp287 = LessEq($Pvalve$Pm_flow_start,100000.0);
    if(!(tmp286 && tmp287))
    {
      tmp289 = modelica_real_to_modelica_string_format($Pvalve$Pm_flow_start, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp288),tmp289);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",315,3,317,61,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.m_flow_start >= -100000.0 and valve.m_flow_start <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp290 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 329
 type: ALGORITHM
 
   assert(valve.m_flow_small >= -100000.0 and valve.m_flow_small <= 100000.0, "Variable valve.m_flow_small out of [min, max] interval: valve.m_flow_small >= -100000.0 and valve.m_flow_small <= 100000.0 has value: " + String(valve.m_flow_small, "g"));
 */
void PipesValveDiscrete_eqFunction_329(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,329};
  modelica_boolean tmp291;
  modelica_boolean tmp292;
  static const MMC_DEFSTRINGLIT(tmp293,134,"Variable valve.m_flow_small out of [min, max] interval: valve.m_flow_small >= -100000.0 and valve.m_flow_small <= 100000.0 has value: ");
  modelica_string tmp294;
  static int tmp295 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp295)
  {
    tmp291 = GreaterEq($Pvalve$Pm_flow_small,-100000.0);
    tmp292 = LessEq($Pvalve$Pm_flow_small,100000.0);
    if(!(tmp291 && tmp292))
    {
      tmp294 = modelica_real_to_modelica_string_format($Pvalve$Pm_flow_small, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp293),tmp294);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/Interfaces.mo",319,3,321,41,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nvalve.m_flow_small >= -100000.0 and valve.m_flow_small <= 100000.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp295 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 330
 type: ALGORITHM
 
   assert(system.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable system.energyDynamics out of [min, max] interval: system.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(system.energyDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_330(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,330};
  modelica_boolean tmp296;
  modelica_boolean tmp297;
  static const MMC_DEFSTRINGLIT(tmp298,215,"Variable system.energyDynamics out of [min, max] interval: system.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp299;
  static int tmp300 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp300)
  {
    tmp296 = GreaterEq((modelica_integer)$Psystem$PenergyDynamics,1);
    tmp297 = LessEq((modelica_integer)$Psystem$PenergyDynamics,4);
    if(!(tmp296 && tmp297))
    {
      tmp299 = modelica_integer_to_modelica_string_format((modelica_integer)$Psystem$PenergyDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp298),tmp299);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",22,3,25,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.energyDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.energyDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp300 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 331
 type: ALGORITHM
 
   assert(system.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable system.momentumDynamics out of [min, max] interval: system.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(system.momentumDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_331(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,331};
  modelica_boolean tmp301;
  modelica_boolean tmp302;
  static const MMC_DEFSTRINGLIT(tmp303,221,"Variable system.momentumDynamics out of [min, max] interval: system.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp304;
  static int tmp305 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp305)
  {
    tmp301 = GreaterEq((modelica_integer)$Psystem$PmomentumDynamics,1);
    tmp302 = LessEq((modelica_integer)$Psystem$PmomentumDynamics,4);
    if(!(tmp301 && tmp302))
    {
      tmp304 = modelica_integer_to_modelica_string_format((modelica_integer)$Psystem$PmomentumDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp303),tmp304);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",35,3,38,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.momentumDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.momentumDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp305 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 332
 type: ALGORITHM
 
   assert(system.eps_m_flow >= 0.0, "Variable system.eps_m_flow out of [min, max] interval: system.eps_m_flow >= 0.0 has value: " + String(system.eps_m_flow, "g"));
 */
void PipesValveDiscrete_eqFunction_332(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,332};
  modelica_boolean tmp306;
  static const MMC_DEFSTRINGLIT(tmp307,91,"Variable system.eps_m_flow out of [min, max] interval: system.eps_m_flow >= 0.0 has value: ");
  modelica_string tmp308;
  static int tmp309 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp309)
  {
    tmp306 = GreaterEq($Psystem$Peps_m_flow,0.0);
    if(!tmp306)
    {
      tmp308 = modelica_real_to_modelica_string_format($Psystem$Peps_m_flow, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp307),tmp308);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",57,3,59,62,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.eps_m_flow >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp309 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 333
 type: ALGORITHM
 
   assert(system.dp_small >= 0.0, "Variable system.dp_small out of [min, max] interval: system.dp_small >= 0.0 has value: " + String(system.dp_small, "g"));
 */
void PipesValveDiscrete_eqFunction_333(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,333};
  modelica_boolean tmp310;
  static const MMC_DEFSTRINGLIT(tmp311,87,"Variable system.dp_small out of [min, max] interval: system.dp_small >= 0.0 has value: ");
  modelica_string tmp312;
  static int tmp313 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp313)
  {
    tmp310 = GreaterEq($Psystem$Pdp_small,0.0);
    if(!tmp310)
    {
      tmp312 = modelica_real_to_modelica_string_format($Psystem$Pdp_small, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp311),tmp312);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",60,3,62,81,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.dp_small >= 0.0", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp313 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 334
 type: ALGORITHM
 
   assert(system.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable system.massDynamics out of [min, max] interval: system.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(system.massDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_334(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,334};
  modelica_boolean tmp314;
  modelica_boolean tmp315;
  static const MMC_DEFSTRINGLIT(tmp316,209,"Variable system.massDynamics out of [min, max] interval: system.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp317;
  static int tmp318 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp318)
  {
    tmp314 = GreaterEq((modelica_integer)$Psystem$PmassDynamics,1);
    tmp315 = LessEq((modelica_integer)$Psystem$PmassDynamics,4);
    if(!(tmp314 && tmp315))
    {
      tmp317 = modelica_integer_to_modelica_string_format((modelica_integer)$Psystem$PmassDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp316),tmp317);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",26,3,28,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.massDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.massDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp318 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 335
 type: ALGORITHM
 
   assert(system.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable system.substanceDynamics out of [min, max] interval: system.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(system.substanceDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_335(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,335};
  modelica_boolean tmp319;
  modelica_boolean tmp320;
  static const MMC_DEFSTRINGLIT(tmp321,224,"Variable system.substanceDynamics out of [min, max] interval: system.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp322;
  static int tmp323 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp323)
  {
    tmp319 = GreaterEq((modelica_integer)$Psystem$PsubstanceDynamics,1);
    tmp320 = LessEq((modelica_integer)$Psystem$PsubstanceDynamics,4);
    if(!(tmp319 && tmp320))
    {
      tmp322 = modelica_integer_to_modelica_string_format((modelica_integer)$Psystem$PsubstanceDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp321),tmp322);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",29,3,31,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.substanceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.substanceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp323 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 336
 type: ALGORITHM
 
   assert(system.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState, "Variable system.traceDynamics out of [min, max] interval: system.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: " + String(system.traceDynamics, "d"));
 */
void PipesValveDiscrete_eqFunction_336(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,336};
  modelica_boolean tmp324;
  modelica_boolean tmp325;
  static const MMC_DEFSTRINGLIT(tmp326,212,"Variable system.traceDynamics out of [min, max] interval: system.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState has value: ");
  modelica_string tmp327;
  static int tmp328 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp328)
  {
    tmp324 = GreaterEq((modelica_integer)$Psystem$PtraceDynamics,1);
    tmp325 = LessEq((modelica_integer)$Psystem$PtraceDynamics,4);
    if(!(tmp324 && tmp325))
    {
      tmp327 = modelica_integer_to_modelica_string_format((modelica_integer)$Psystem$PtraceDynamics, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp326),tmp327);
      {
        FILE_INFO info = {"/opt/openmodelica/lib/omlibrary/Modelica 3.2.1/Fluid/System.mo",32,3,34,77,1};
        omc_assert_warning(info, "The following assertion has been violated at time %f\nsystem.traceDynamics >= Modelica.Fluid.Types.Dynamics.DynamicFreeInitial and system.traceDynamics <= Modelica.Fluid.Types.Dynamics.SteadyState", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp328 = 1;
    }
  }
  TRACE_POP
}
int PipesValveDiscrete_updateBoundParameters(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  PipesValveDiscrete_eqFunction_230(data, threadData);

  PipesValveDiscrete_eqFunction_231(data, threadData);

  PipesValveDiscrete_eqFunction_232(data, threadData);

  PipesValveDiscrete_eqFunction_233(data, threadData);

  PipesValveDiscrete_eqFunction_234(data, threadData);

  PipesValveDiscrete_eqFunction_235(data, threadData);

  PipesValveDiscrete_eqFunction_236(data, threadData);

  PipesValveDiscrete_eqFunction_237(data, threadData);

  PipesValveDiscrete_eqFunction_238(data, threadData);

  PipesValveDiscrete_eqFunction_239(data, threadData);

  PipesValveDiscrete_eqFunction_240(data, threadData);

  PipesValveDiscrete_eqFunction_241(data, threadData);

  PipesValveDiscrete_eqFunction_242(data, threadData);

  PipesValveDiscrete_eqFunction_243(data, threadData);

  PipesValveDiscrete_eqFunction_244(data, threadData);

  PipesValveDiscrete_eqFunction_245(data, threadData);

  PipesValveDiscrete_eqFunction_246(data, threadData);

  PipesValveDiscrete_eqFunction_247(data, threadData);

  PipesValveDiscrete_eqFunction_248(data, threadData);

  PipesValveDiscrete_eqFunction_249(data, threadData);

  PipesValveDiscrete_eqFunction_250(data, threadData);

  PipesValveDiscrete_eqFunction_251(data, threadData);

  PipesValveDiscrete_eqFunction_252(data, threadData);

  PipesValveDiscrete_eqFunction_253(data, threadData);

  PipesValveDiscrete_eqFunction_254(data, threadData);

  PipesValveDiscrete_eqFunction_255(data, threadData);

  PipesValveDiscrete_eqFunction_256(data, threadData);

  PipesValveDiscrete_eqFunction_257(data, threadData);

  PipesValveDiscrete_eqFunction_258(data, threadData);

  PipesValveDiscrete_eqFunction_259(data, threadData);

  PipesValveDiscrete_eqFunction_260(data, threadData);

  PipesValveDiscrete_eqFunction_261(data, threadData);

  PipesValveDiscrete_eqFunction_262(data, threadData);

  PipesValveDiscrete_eqFunction_263(data, threadData);

  PipesValveDiscrete_eqFunction_264(data, threadData);

  PipesValveDiscrete_eqFunction_265(data, threadData);

  PipesValveDiscrete_eqFunction_266(data, threadData);

  PipesValveDiscrete_eqFunction_267(data, threadData);

  PipesValveDiscrete_eqFunction_268(data, threadData);

  PipesValveDiscrete_eqFunction_269(data, threadData);

  PipesValveDiscrete_eqFunction_270(data, threadData);

  PipesValveDiscrete_eqFunction_271(data, threadData);

  PipesValveDiscrete_eqFunction_272(data, threadData);

  PipesValveDiscrete_eqFunction_273(data, threadData);

  PipesValveDiscrete_eqFunction_274(data, threadData);

  PipesValveDiscrete_eqFunction_275(data, threadData);

  PipesValveDiscrete_eqFunction_276(data, threadData);

  PipesValveDiscrete_eqFunction_277(data, threadData);

  PipesValveDiscrete_eqFunction_278(data, threadData);

  PipesValveDiscrete_eqFunction_279(data, threadData);

  PipesValveDiscrete_eqFunction_280(data, threadData);

  PipesValveDiscrete_eqFunction_281(data, threadData);

  PipesValveDiscrete_eqFunction_282(data, threadData);

  PipesValveDiscrete_eqFunction_283(data, threadData);

  PipesValveDiscrete_eqFunction_284(data, threadData);

  PipesValveDiscrete_eqFunction_285(data, threadData);

  PipesValveDiscrete_eqFunction_286(data, threadData);

  PipesValveDiscrete_eqFunction_287(data, threadData);

  PipesValveDiscrete_eqFunction_288(data, threadData);

  PipesValveDiscrete_eqFunction_289(data, threadData);

  PipesValveDiscrete_eqFunction_290(data, threadData);

  PipesValveDiscrete_eqFunction_291(data, threadData);

  PipesValveDiscrete_eqFunction_292(data, threadData);

  PipesValveDiscrete_eqFunction_293(data, threadData);

  PipesValveDiscrete_eqFunction_294(data, threadData);

  PipesValveDiscrete_eqFunction_295(data, threadData);

  PipesValveDiscrete_eqFunction_296(data, threadData);

  PipesValveDiscrete_eqFunction_297(data, threadData);

  PipesValveDiscrete_eqFunction_298(data, threadData);

  PipesValveDiscrete_eqFunction_299(data, threadData);

  PipesValveDiscrete_eqFunction_300(data, threadData);

  PipesValveDiscrete_eqFunction_301(data, threadData);

  PipesValveDiscrete_eqFunction_302(data, threadData);

  PipesValveDiscrete_eqFunction_303(data, threadData);

  PipesValveDiscrete_eqFunction_304(data, threadData);

  PipesValveDiscrete_eqFunction_305(data, threadData);

  PipesValveDiscrete_eqFunction_306(data, threadData);

  PipesValveDiscrete_eqFunction_307(data, threadData);

  PipesValveDiscrete_eqFunction_308(data, threadData);

  PipesValveDiscrete_eqFunction_309(data, threadData);

  PipesValveDiscrete_eqFunction_310(data, threadData);

  PipesValveDiscrete_eqFunction_311(data, threadData);

  PipesValveDiscrete_eqFunction_312(data, threadData);

  PipesValveDiscrete_eqFunction_313(data, threadData);

  PipesValveDiscrete_eqFunction_314(data, threadData);

  PipesValveDiscrete_eqFunction_315(data, threadData);

  PipesValveDiscrete_eqFunction_316(data, threadData);

  PipesValveDiscrete_eqFunction_317(data, threadData);

  PipesValveDiscrete_eqFunction_318(data, threadData);

  PipesValveDiscrete_eqFunction_319(data, threadData);

  PipesValveDiscrete_eqFunction_320(data, threadData);

  PipesValveDiscrete_eqFunction_321(data, threadData);

  PipesValveDiscrete_eqFunction_322(data, threadData);

  PipesValveDiscrete_eqFunction_323(data, threadData);

  PipesValveDiscrete_eqFunction_324(data, threadData);

  PipesValveDiscrete_eqFunction_325(data, threadData);

  PipesValveDiscrete_eqFunction_326(data, threadData);

  PipesValveDiscrete_eqFunction_327(data, threadData);

  PipesValveDiscrete_eqFunction_328(data, threadData);

  PipesValveDiscrete_eqFunction_329(data, threadData);

  PipesValveDiscrete_eqFunction_330(data, threadData);

  PipesValveDiscrete_eqFunction_331(data, threadData);

  PipesValveDiscrete_eqFunction_332(data, threadData);

  PipesValveDiscrete_eqFunction_333(data, threadData);

  PipesValveDiscrete_eqFunction_334(data, threadData);

  PipesValveDiscrete_eqFunction_335(data, threadData);

  PipesValveDiscrete_eqFunction_336(data, threadData);
  
  TRACE_POP
  return 0;
}

#if defined(__cplusplus)
}
#endif

