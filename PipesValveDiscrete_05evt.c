/* Events: Sample, Zero Crossings, Relations, Discrete Changes */
/* Simulation code for PipesValveDiscrete generated by the OpenModelica Compiler OpenModelica 1.9.3. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "PipesValveDiscrete_functions.h"
#include "PipesValveDiscrete_model.h"
#include "PipesValveDiscrete_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#if defined(__cplusplus)
extern "C" {
#endif

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void PipesValveDiscrete_function_initSample(DATA *data, threadData_t *threadData)
{
  long i=0;
}

const char *PipesValveDiscrete_zeroCrossingDescription(int i, int **out_EquationIndexes)
{
  static const char *res[] = {"tank1.level >= tank1.portsData[1].height",
  "tank2.level >= tank2.portsData[1].height",
  "time >= valveOpening.startTime",
  "not tank1.regularFlow[1] and (tank1.s[1] > 0.0 or tank1.portsData[1].height >= 1.1)",
  "not tank2.regularFlow[1] and (tank2.s[1] > 0.0 or tank2.portsData[1].height >= 1.1)"};
  static const int occurEqs0[] = {1,150};
  static const int occurEqs1[] = {1,141};
  static const int occurEqs2[] = {1,140};
  static const int occurEqs3[] = {1,-1};
  static const int occurEqs4[] = {1,-1};
  static const int *occurEqs[] = {occurEqs0,occurEqs1,occurEqs2,occurEqs3,occurEqs4};
  *out_EquationIndexes = (int*) occurEqs[i];
  return res[i];
}

/* forwarded equations */
extern void PipesValveDiscrete_eqFunction_140(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_141(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_142(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_143(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_146(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_147(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_148(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_150(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_151(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_152(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_155(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_156(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_172(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_173(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_174(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_176(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_177(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_184(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_188(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_189(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_190(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_191(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_194(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_195(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_196(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_197(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_199(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_200(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_201(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_202(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_203(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_204(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_206(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_207(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_208(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_209(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_210(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_212(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_213(DATA* data, threadData_t *threadData);
extern void PipesValveDiscrete_eqFunction_214(DATA* data, threadData_t *threadData);

int PipesValveDiscrete_function_ZeroCrossingsEquations(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  data->simulationInfo.callStatistics.functionZeroCrossingsEquations++;
  
  PipesValveDiscrete_eqFunction_140(data, threadData);

  PipesValveDiscrete_eqFunction_141(data, threadData);

  PipesValveDiscrete_eqFunction_142(data, threadData);

  PipesValveDiscrete_eqFunction_143(data, threadData);

  PipesValveDiscrete_eqFunction_146(data, threadData);

  PipesValveDiscrete_eqFunction_147(data, threadData);

  PipesValveDiscrete_eqFunction_148(data, threadData);

  PipesValveDiscrete_eqFunction_150(data, threadData);

  PipesValveDiscrete_eqFunction_151(data, threadData);

  PipesValveDiscrete_eqFunction_152(data, threadData);

  PipesValveDiscrete_eqFunction_155(data, threadData);

  PipesValveDiscrete_eqFunction_156(data, threadData);

  PipesValveDiscrete_eqFunction_172(data, threadData);

  PipesValveDiscrete_eqFunction_173(data, threadData);

  PipesValveDiscrete_eqFunction_174(data, threadData);

  PipesValveDiscrete_eqFunction_176(data, threadData);

  PipesValveDiscrete_eqFunction_177(data, threadData);

  PipesValveDiscrete_eqFunction_184(data, threadData);

  PipesValveDiscrete_eqFunction_188(data, threadData);

  PipesValveDiscrete_eqFunction_189(data, threadData);

  PipesValveDiscrete_eqFunction_190(data, threadData);

  PipesValveDiscrete_eqFunction_191(data, threadData);

  PipesValveDiscrete_eqFunction_194(data, threadData);

  PipesValveDiscrete_eqFunction_195(data, threadData);

  PipesValveDiscrete_eqFunction_196(data, threadData);

  PipesValveDiscrete_eqFunction_197(data, threadData);

  PipesValveDiscrete_eqFunction_199(data, threadData);

  PipesValveDiscrete_eqFunction_200(data, threadData);

  PipesValveDiscrete_eqFunction_201(data, threadData);

  PipesValveDiscrete_eqFunction_202(data, threadData);

  PipesValveDiscrete_eqFunction_203(data, threadData);

  PipesValveDiscrete_eqFunction_204(data, threadData);

  PipesValveDiscrete_eqFunction_206(data, threadData);

  PipesValveDiscrete_eqFunction_207(data, threadData);

  PipesValveDiscrete_eqFunction_208(data, threadData);

  PipesValveDiscrete_eqFunction_209(data, threadData);

  PipesValveDiscrete_eqFunction_210(data, threadData);

  PipesValveDiscrete_eqFunction_212(data, threadData);

  PipesValveDiscrete_eqFunction_213(data, threadData);

  PipesValveDiscrete_eqFunction_214(data, threadData);
  
  TRACE_POP
  return 0;
}

int PipesValveDiscrete_function_ZeroCrossings(DATA *data, threadData_t *threadData, double *gout)
{
  TRACE_PUSH
  modelica_boolean tmp1159;
  modelica_boolean tmp1160;
  modelica_boolean tmp1161;
  modelica_boolean tmp1162;
  modelica_boolean tmp1163;
  modelica_boolean tmp1164;
  modelica_boolean tmp1165;
  
  data->simulationInfo.callStatistics.functionZeroCrossings++;
  
  tmp1159 = GreaterEqZC($Ptank1$Plevel, $Ptank1$PportsData$lB1$rB$Pheight, data->simulationInfo.storedRelations[0]);
  gout[0] = (tmp1159) ? 1 : -1;
  tmp1160 = GreaterEqZC($Ptank2$Plevel, $Ptank2$PportsData$lB1$rB$Pheight, data->simulationInfo.storedRelations[1]);
  gout[1] = (tmp1160) ? 1 : -1;
  tmp1161 = GreaterEqZC(data->localData[0]->timeValue, $PvalveOpening$PstartTime, data->simulationInfo.storedRelations[2]);
  gout[2] = (tmp1161) ? 1 : -1;
  tmp1162 = GreaterZC($Ptank1$Ps$lB1$rB, 0.0, data->simulationInfo.storedRelations[3]);
  tmp1163 = GreaterEq($Ptank1$PportsData$lB1$rB$Pheight,1.1);
  gout[3] = (((!$Ptank1$PregularFlow$lB1$rB) && (tmp1162 || tmp1163))) ? 1 : -1;
  tmp1164 = GreaterZC($Ptank2$Ps$lB1$rB, 0.0, data->simulationInfo.storedRelations[4]);
  tmp1165 = GreaterEq($Ptank2$PportsData$lB1$rB$Pheight,1.1);
  gout[4] = (((!$Ptank2$PregularFlow$lB1$rB) && (tmp1164 || tmp1165))) ? 1 : -1;
  
  TRACE_POP
  return 0;
}

const char *PipesValveDiscrete_relationDescription(int i)
{
  const char *res[] = {"tank1.level >= tank1.portsData[1].height",
  "tank2.level >= tank2.portsData[1].height",
  "time >= valveOpening.startTime",
  "tank1.s[1] > 0.0",
  "tank2.s[1] > 0.0"};
  return res[i];
}

int PipesValveDiscrete_function_updateRelations(DATA *data, threadData_t *threadData, int evalforZeroCross)
{
  TRACE_PUSH
  modelica_boolean tmp1166;
  modelica_boolean tmp1167;
  modelica_boolean tmp1168;
  modelica_boolean tmp1169;
  modelica_boolean tmp1170;
  
  if(evalforZeroCross) {
    tmp1166 = GreaterEqZC($Ptank1$Plevel, $Ptank1$PportsData$lB1$rB$Pheight, data->simulationInfo.storedRelations[0]);
    data->simulationInfo.relations[0] = tmp1166;
    tmp1167 = GreaterEqZC($Ptank2$Plevel, $Ptank2$PportsData$lB1$rB$Pheight, data->simulationInfo.storedRelations[1]);
    data->simulationInfo.relations[1] = tmp1167;
    tmp1168 = GreaterEqZC(data->localData[0]->timeValue, $PvalveOpening$PstartTime, data->simulationInfo.storedRelations[2]);
    data->simulationInfo.relations[2] = tmp1168;
    tmp1169 = GreaterZC($Ptank1$Ps$lB1$rB, 0.0, data->simulationInfo.storedRelations[3]);
    data->simulationInfo.relations[3] = tmp1169;
    tmp1170 = GreaterZC($Ptank2$Ps$lB1$rB, 0.0, data->simulationInfo.storedRelations[4]);
    data->simulationInfo.relations[4] = tmp1170;
  } else {
    data->simulationInfo.relations[0] = ($Ptank1$Plevel >= $Ptank1$PportsData$lB1$rB$Pheight);
    data->simulationInfo.relations[1] = ($Ptank2$Plevel >= $Ptank2$PportsData$lB1$rB$Pheight);
    data->simulationInfo.relations[2] = (data->localData[0]->timeValue >= $PvalveOpening$PstartTime);
    data->simulationInfo.relations[3] = ($Ptank1$Ps$lB1$rB > 0.0);
    data->simulationInfo.relations[4] = ($Ptank2$Ps$lB1$rB > 0.0);
  }
  
  TRACE_POP
  return 0;
}

int PipesValveDiscrete_checkForDiscreteChanges(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  int needToIterate = 0;

  infoStreamPrint(LOG_EVENTS_V, 1, "check for discrete changes at time=%.12g", data->localData[0]->timeValue);
  if($Ptank1$PregularFlow$lB1$rB != $P$PRE$Ptank1$PregularFlow$lB1$rB)
  {
    infoStreamPrint(LOG_EVENTS_V, 0, "discrete var changed: tank1._regularFlow[1] from %d to %d", $P$PRE$Ptank1$PregularFlow$lB1$rB, $Ptank1$PregularFlow$lB1$rB);
    needToIterate = 1;
  }
  if($Ptank1$PinFlow$lB1$rB != $P$PRE$Ptank1$PinFlow$lB1$rB)
  {
    infoStreamPrint(LOG_EVENTS_V, 0, "discrete var changed: tank1._inFlow[1] from %d to %d", $P$PRE$Ptank1$PinFlow$lB1$rB, $Ptank1$PinFlow$lB1$rB);
    needToIterate = 1;
  }
  if($Ptank2$PregularFlow$lB1$rB != $P$PRE$Ptank2$PregularFlow$lB1$rB)
  {
    infoStreamPrint(LOG_EVENTS_V, 0, "discrete var changed: tank2._regularFlow[1] from %d to %d", $P$PRE$Ptank2$PregularFlow$lB1$rB, $Ptank2$PregularFlow$lB1$rB);
    needToIterate = 1;
  }
  if($Ptank2$PinFlow$lB1$rB != $P$PRE$Ptank2$PinFlow$lB1$rB)
  {
    infoStreamPrint(LOG_EVENTS_V, 0, "discrete var changed: tank2._inFlow[1] from %d to %d", $P$PRE$Ptank2$PinFlow$lB1$rB, $Ptank2$PinFlow$lB1$rB);
    needToIterate = 1;
  }
  if($Pvalve$Popen != $P$PRE$Pvalve$Popen)
  {
    infoStreamPrint(LOG_EVENTS_V, 0, "discrete var changed: valve._open from %d to %d", $P$PRE$Pvalve$Popen, $Pvalve$Popen);
    needToIterate = 1;
  }
  if (ACTIVE_STREAM(LOG_EVENTS_V)) messageClose(LOG_EVENTS_V);
  
  TRACE_POP
  return needToIterate;
}

#if defined(__cplusplus)
}
#endif

